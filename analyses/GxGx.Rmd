---
title: "Genotype x genotype interactions in host manipulation"
author: "Dan Benesh"
output: html_document
---

```{r setup, include=FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
options(stringsAsFactors = FALSE)
theme_set(new = theme_bw())
```

# Experiment Background
Many parasites manipulate the behavior of their hosts in ways that seem beneficial. Little is known about genetic variation in this phenotype. Are parasites genetically variable in how much they manipulate host behavior? Do different host genotypes resist manipulation better than others? I infected 5 host strains with 5 parasite strains to quantify the variability in host manipulation due to parasite genes, host genes, and their interactions. The host-parasite system I used was the tapeworm *Schistocephalus solidus* in its copepod first intermediate host.

```{r importdata}
# import data
bd <- read.csv(file = "../data/behav_combined_after_qc2.csv", header = TRUE) # manual data
bdr <- read.csv(file = "../data/behav_combined_auto_tracked_corrected.csv", header = TRUE) # auto-tracked data
infd <- read.csv(file = "../data/GxG_inf.csv", header = TRUE, fileEncoding = "UTF-8-BOM") #excel attached BOM to csv
```

Copepod movement was video recorded for two minutes. After one minute, the well plate containing the copepods was dropped in a standardized way to simulate a predator attack and 'frighten' the copepods. Each copepod was recorded on several days throughout the course of parasite development (from uninfective to infective larva). 

Recordings were both manually- (clicking on copepod position frame-by-frame) and automatically-processed (with a tracking program). The output from the two approaches was quite similar (see an extensive comparison [here](GITHUB LINK!!)). Each approach has some advantages and disadvantages. First of all, I identified mistakes in the manually-processed data, like incorrect number of frames, etc. (see [here](GITHUB LINK)); this human error motivated the development of an auto-tracker. The auto-tracker allowed additional videos and copepods to be processed that were not included in the manual data for lack of time. However, the auto-tracker was also not free from mistakes, occassionally recording large movements that were not. Here I make sure that both datasets yield concordant results.

In this notebook, I first present descriptive statistics from the experiment. Then, I look at ways of quantifying behavior and defining the response variable. Next, I conduct exploratory analyses of the factors impacting the response variable. Finally, I fit models to test the hypothesis of genotype-by-genotype interactions.

```{r}
# Select and rename columns
bd <- select(bd, fname, cop_name, day, 
             slice = Slice.n., x = X, y = Y,
             dist = Distance, pixel = Pixel.Value, 
             ok_col_names, ok_col_num, ok_row_num)%>%
  arrange(day, cop_name, slice)

# for first observation of every video, no 'distance moved' can be calculated; replace with NA
bd$dist[bd$slice == 1 & bd$dist == -1] <- NA

# create new variables
bd <- mutate(bd, time_sec = slice * 2 - 4)

# make fname consistent with auto-tracked file
bd <- mutate(bd, fname = if_else(day > 10, paste0(cop_name, "_", day),
                          paste0(cop_name, "_0", day)))
```

# Descriptive Statistics

Let's look at some basic stats. How many copepods were in the experiment?

```{r}
# correct problem from import with `cop_name` column
if(grepl(pattern = "?..", names(infd)[1])) { # if first column name has weird '?..' after import...
  names(infd)[1] <- 'cop_name' # change it
} 

# create new trt var with unexposed and uninfecteds pooled
infd$trt2 <- infd$trt
infd$trt2[which(infd$infected == 0)] <- 'uninfected'
```
```{r}
sum(!is.na(infd$exposed)) # if included, cops had a value for 'exposed' variable
```

How many were exposed to infection?

```{r}
sum(infd$exposed == 1, na.rm=T)
```

The rest were unexposed controls (n = `r sum( infd$exposed == 0, na.rm=T)`).

Whether copepods were infected or not was checked after a week. How many survived until being checked for infection?

```{r}
sum( !is.na(infd$infected) )
```

And how many were infected?

```{r}
sum(infd$infected == 1, na.rm=T)
```

So the infection rate was `r round(sum(infd$infected == 1, na.rm=T) / sum( infd$exposed == 1, na.rm=T), 3) * 100`%.

We can also do some quality control checks on our infection data. For example, I measured some parasite traits like cercomere presence (an indication of developmental rate) and worm size. So we can check to make sure these variables are only recorded from infected copepods, starting with cercomere presence. 

It is, though 5 infected copepods are missing cercomere data.
```{r}
table(!is.na(infd$cerc_d9), infd$trt)
```

Similarly, worm size was only recorded from infected copepods, though in 99 it was not measured. Most of those without size measurement died before the end of the experiment 21 days post exposure.

```{r}
table(!is.na(infd$proc_size1), infd$trt)
```

Worm size was measured twice. The two measures are highly correlated, with a pearson correlation coefficient of `r round( with(infd, cor(proc_size1, proc_size2, use = "pairwise")), 2)`, though there was some variation in the measurements.

```{r message=FALSE, warning=FALSE}
qplot(data = infd, x = proc_size1, y = proc_size2) + theme_bw()
```

Presumably, this is normal measurement error due to e.g. photo angles, moving worms, etc. The average of the two body size measurements is taken as the best measure of larval size in future analyses.

```{r}
infd <- mutate(infd, proca = (proc_size1 + proc_size2)/2) # average of 2 proc measurements
```

Moving on to the behavior data, how many copepods had their behavior recorded manually?

```{r}
bd_cops <- unique(bd$cop_name)
length(bd_cops)
```

How many were recorded automatically?

```{r}
bdr <- mutate(bdr, cop_name = substr(fname, 1, 5))
bd_cops <- unique((bdr$cop_name))
length(bd_cops)
```

There are 5 cop families and 5 parasite families. How many infected cops are in each group?

```{r}
# reduce infection df to just infected cops with manual behav measurements, make table
t <- with(filter(infd, cop_name %in% bd$cop_name, trt2 == 'infected'),
     table(cop_fam, parasite_fam))
t
```

It ranges from `r min(t)` to `r max(t)` per combination, with an average of `r mean(t)`. This is the same for both auto- and manually-tracked behavior data, as all infecteds but not all uninfecteds were tracked.

What about uninfecteds? Let's check the numbers of unexposed controls and exposed-but-uninfected copepods in each copepod family. Generally about 30 per family in the manually-tracked data.

```{r}
# reduce infection df to just uninfected cops with manual behav measurements, make table
t <- with(filter(infd, cop_name %in% bd$cop_name, infected == 0),
     table(cop_fam, trt))
t
```

In the auto-tracked data, additional exposed-but-uninfected copepods were tracked with the auto-tracker. This should provide a better baseline for the behavior of uninfected copepods in each family.

```{r}
# Auto tracked table of uninfecteds
t <- with(filter(infd, cop_name %in% bdr$cop_name, infected == 0),
     table(cop_fam, trt))
t
```

Each copepod was observed on multiple days over the course of the experiment. In the manual dataset, how many times were copepods observed on average?

```{r}
# manual data
n_rec <- select(bd, cop_name, day)%>%distinct()%>%group_by(cop_name)%>%summarize(n_rec = n())
n_rec <- left_join(n_rec, select(infd, cop_name, trt))
tapply(n_rec$n_rec, n_rec$trt, mean)
# round(prop.table(table(n_rec$trt, n_rec$n_rec), margin = 1), 2)
```

In each treatment group, there were nearly 7 observations per copepod, corresponding to days 5, 7, 9, 11, 13, 15, and 17 post-infection. Sometimes, copepods died before the end of the experiment, which is why there were fewer observations for some individuals. What about the auto-tracking data?

```{r}
# auto data
bdr <- mutate(bdr, day = substr(fname, start = 7, stop = 8))
n_rec <- select(bdr, cop_name, day)%>%distinct()%>%group_by(cop_name)%>%summarize(n_rec = n())
n_rec <- left_join(n_rec, select(infd, cop_name, trt))
tapply(n_rec$n_rec, n_rec$trt, mean)
# round(prop.table(table(n_rec$trt, n_rec$n_rec), margin = 1), 2)
```

The average number of recordings processed increased to over 8 per copepod. This is because I used the auto-tracker to process additional videos taken at days 19 and 21 postinfection that were not previously manually-processed.

# Define Response Variables

What measures of copepod behavior should we extract from the videos? What should be our response variable? How can we simplify the very fine frame-by-frame data to something more manageable and understandable? First, I examine how three measures of copepod behavior vary over a recording. Second, I check ways to simplify the measurements to ease modelling and improve understanding.

## Behavioral measures
### Measure 1 - speed

The simplest measurement is the distance moved between frames. We can also call this copepod's speed, given that it is a distance moved in a defined time. Behavior was filmed over two minutes, with the plate being dropped in the middle of the recording. So *a priori* we can divide a recording into three sections: before the drop, during the drop, and after the drop.  Let's see how average speed changes throughout a recording.

```{r}
bdr_avg <- group_by(bdr, sec)%>%
  summarize(mean_dist = mean(distance, na.rm = T),
            mean_dp = mean(dot_product, na.rm = T))%>%
  mutate(group = if_else(sec < 58.5, 'before the drop', 
                         if_else(sec > 61.5, 'after the drop', 'drop')))

ggplot(bdr_avg, aes(x = sec, y = mean_dist)) + 
  geom_path() + geom_point(aes(color=group)) +
  scale_x_continuous(limits = c(0,120), breaks = seq(0, 120, by = 10)) +
  labs(title = 'auto tracker, 8 frames/s', color = 'section', x = 'seconds', y = 'speed')
```
```{r warning=FALSE}
bd_avg <- group_by(bd, time_sec)%>%
  summarize(mean_dist = mean(dist, na.rm=T))%>%
  mutate(group = if_else(time_sec < 59, 'before the drop', 
                         if_else(time_sec > 62, 'after the drop', 'drop')))
  
ggplot(bd_avg, aes(x = time_sec, y = mean_dist)) + 
  geom_path() + geom_point(aes(color=group)) +
  scale_x_continuous(limits = c(0,120), breaks = seq(0, 120, by = 10)) +
  labs(title = 'manual tracker, 1 frame/2 s', color = 'section', x = 'seconds', y = 'speed')
```

The most conspicuous pattern is the spike at 60 second during the drop. In fact, the copepod moves so fast during this drop that it cannot be reliably tracked, even at the high frame rate of an 8/second. The slight change in plate position through the drop also causes problems with background subtraction in the auto-tracking program. The values during the plate drop cannot be considered accurate and need to be removed before analyses. But how much should we remove on either side of the drop? 

Let's zoom in on the drop. Just eyeballing it, it seems like taking the 1.5 seconds on either side of the drop seems to reasonably exclude most of the peak.

```{r}
ggplot(bdr_avg, aes(x = sec, y = mean_dist)) + 
  geom_path() + geom_point(aes(color=group)) +
  labs(title = 'auto tracker, 8 frames/s', x = 'seconds', y = 'speed') + 
  scale_y_log10() + coord_cartesian(xlim = c(50, 70))
```

When we exclude the data around the drop, we see more clearly how copepods respond. 

```{r}
ggplot(filter(bdr_avg, group != 'drop'), 
       aes(x = sec, y = mean_dist, color = group)) + 
  geom_path() + 
  scale_x_continuous(limits = c(0,120), breaks = seq(0, 120, by = 10)) +
  labs(title = 'auto tracker, 8 frames/s', x = 'seconds', y = 'speed')
```
```{r}
ggplot(filter(bd_avg, group != 'drop'), 
       aes(x = time_sec, y = mean_dist, color = group)) + 
  geom_path() + 
  scale_x_continuous(limits = c(0,120), breaks = seq(0, 120, by = 10)) +
  labs(title = 'manual tracking', x = 'seconds', y = 'speed')
```

There is a clear decrease in activity directly after the drop, but the copepods seem to recover rather quickly so that by the end of the recording their activity levels have recovered. Also, in the auto-tracked data, there is still a spike shortly before the drop, which was not observed in the manual data. I think this represents a problem with how background subtraction works at the 'edges' of the video (i.e. before and after the drop). Presumably, this is random error and it shouldn't bias treatment differences, but it might be worth excluding a little more than 1.5 seconds on both sides of the drop.

### Measure 2 - time moving

Instead of asking how far/fast a copepod moved in a given time frame, we can ask if it was moving at all. This may provide some additional nuance, because a copepod can move the same distance over a recodring in different ways, e.g. steady, slow movements vs. a few large, fast movements. Previous studies (LINK!!!)[] using the same recording approach have examined two behavior variables: i) whether a copepod was moving and ii) if yes, how fast/far it was moving. These two behavioral variables are components of the 'speed' measure used above, but let's separate them to see if it adds any information. In particular, we are interested in how they are affected by infection.

```{r}
# tag frames where cop not-moving
# auto
bdr <- mutate(bdr, moving = if_else(distance < 0.13, 0, 1))
# manual
bd <- mutate(bd, moving = if_else(dist < 0.13, 0, 1))
# value of 0.13 was used as cutoff to designate non-moving tiny oscillattions, because it represented a one pixel move in the manual data, which is presumably due to clicking in a slightly different spot than a genuine change in copepod position
```

We can plot how both variables from both datasets vary over the recording period, starting with whether copepods were moving or not.

```{r}
# plot over time for auto tracker
bdr_avg2 <- filter(bdr, !is.na(moving))%>%
  group_by(sec)%>%
  summarise(moving = sum(moving, na.rm = T) , n = n())%>%
  mutate(prop_moving = moving/n, 
         group = if_else(sec < 58.5, 'before the drop', if_else(sec > 61.5, 'after the drop', 'drop')))

ggplot(bdr_avg2, aes(x = sec, y = prop_moving)) + 
  geom_line() +
  geom_point(aes(color = group)) +
  labs(title = 'auto tracker', x = 'seconds', y = 'proportion moving') +
  scale_y_continuous(limits = c(0,1))
```
```{r}
# plot over time for manual tracking
bd_avg2 <- filter(bd, !is.na(moving), time_sec != -2)%>%
  group_by(time_sec)%>%
  summarise(moving = sum(moving, na.rm = T) , n = n())%>%
  mutate(prop_moving = moving/n, 
         group = if_else(time_sec < 59, 'before the drop', if_else(time_sec > 62, 'after the drop', 'drop')))

ggplot(bd_avg2, aes(x = time_sec, y = prop_moving)) +
  geom_line() +
  geom_point(aes(color = group)) +
  labs(title = 'manual tracking', x = 'seconds', y = 'proportion moving') +
  scale_y_continuous(limits = c(0,1))
```

As expected, the patterns are very similar to those observed for 'average speed' above. The auto tracker seems to miss some movements at the start of the recording, which probably has to do with how quickly the video's 'background' is established and then subtracted out by the movement detection algorithm. It also detects less movement overall, due to the higher frame rate - more movement can happen in 2 seconds (manual frame rate) than in an 1/8 of a second (auto frame rate).

Now we plot the second variable: how far a copepod moves, given that it is moving. I'll call this hop distance, as this implies movement. Here there is a conspicuous difference between auto and manually tracked data.
```{r}
bdr_avg3 <- filter(bdr, moving == 1)%>%
  group_by(sec)%>%
  summarize(mean_dist = mean(distance, na.rm=T), sd = sd(distance), n = n())%>%
  mutate(se = sd/sqrt(n),
         group = if_else(sec < 58.5, 'before the drop', if_else(sec > 61.5, 'after the drop', 'drop')))

ggplot(filter(bdr_avg3, group != 'drop'),
       aes(x = sec, y = mean_dist, color = group, fill = group)) + 
  geom_ribbon(aes(ymin = mean_dist - 1.96*se, ymax = mean_dist + 1.96*se)) +
  geom_path(color = 'black') +
  labs(title = 'auto tracker', x = 'seconds', y = 'mean hop distance + CI')

```
```{r}
bd_avg3 <- filter(bd, moving == 1, time_sec != -2)%>%
  group_by(time_sec)%>%
  summarize(mean_hop_dist = mean(dist, na.rm=T), sd = sd(dist), n =n())%>%
  mutate(se = sd/sqrt(n),
         group = if_else(time_sec < 59, 'before the drop', if_else(time_sec > 62, 'after the drop', 'drop')))

ggplot(filter(bd_avg3, group != 'drop'),
       aes(x = time_sec, y = mean_hop_dist, color = group, fill = group)) + 
  geom_ribbon(aes(ymin = mean_hop_dist - 1.96*se, ymax = mean_hop_dist + 1.96*se)) +
  geom_path(color = 'black') +
  labs(title = 'manual tracking', x = 'seconds', y = 'mean hop distance + CI')
```

Right after the drop, copepods seems to exhibit large movements in the auto dataset, which is tempting to interpet as escape movements, but the opposite is seen in the manual tracking data. There copepods exhibit smaller hops after the drop. So, again it looks like there some auto-tracking artifacts, probably due to the background being shifted when a plate is dropped. However, looking beyond the time period shortly after the drop, we see the hop distances are rather comparable before and after the plate drop. So, copepods do not appear to clearly alter their behavior by moving faster or slower in response to the drop.

Time moving and hop distance exhibit different patterns over the recording, suggesting they are not correlated and thus provide some independent information on copepod behavior. However, we can check the correlation between these two variables. The next plot shows the average hop distance during a recording as a function of the time spent moving.

```{r}
# remove drop and missing data
bdr_comp <- filter(bdr, sec < 59 | sec > 61, !is.na(distance))%>%
  group_by(fname)%>%
  summarise(n = n(), tot_dist = sum(distance), moving = sum(moving))%>%
  mutate(avg_vel = tot_dist/n, avg_vel_when_moving = tot_dist/moving, prop_moving = moving/n)

ggplot(bdr_comp, aes(x = prop_moving, y = avg_vel_when_moving)) + 
  geom_point(alpha = 0.051) +
  geom_smooth(method = 'lm', se = F) +
  labs(title = 'auto tracking', x = 'proportion moving', y = 'mean hop distance')
```

There are very high hop distance values in copepods that hardly moved. This is because, when few movements are detected, a single large, perhaps-erroneously-recorded movement determines the average hop distance. When we zoom in to exclude the copepods with a few, high magnitude movements, then we see that there is not a strong correlation between these variables. The residual variation suggests that in some recordings copepods are more slow and steady movers while in others they are more fast and jerky. 

```{r}
ggplot(bdr_comp, aes(x = prop_moving, y = avg_vel_when_moving)) + 
  geom_point(alpha = 0.3) +
  geom_smooth(method = 'lm', se = F) +
  scale_x_continuous(limits = c(0.05, 0.9)) + scale_y_continuous(limits = c(0,10)) +
  labs(title = 'auto tracking', x = 'proportion moving', y = 'mean hop distance')
```

In this experiment, we want to know how infection affects where copepods land on this plot. Additionally, we would like to know if there is a clear response to the plate drop in one or both of these variables. Let's add median values for the infection groups to the above plot and split it by the recording period, before and after the drop.

```{r}
# new ways of showing two responses, trt, and recording time together
bdr_avg4 <- filter(bdr, sec < 58 | sec > 62, !is.na(distance))%>%
  mutate(drop = if_else(sec < 60, 'before', 'after'))%>%
  group_by(fname, drop)%>%
  summarise(n = n(), tot_dist = sum(distance), moving = sum(moving))%>%
  mutate(avg_vel = tot_dist/n, avg_vel_when_moving = tot_dist/moving, prop_moving = moving/n)%>%
  mutate(drop = factor(drop, levels = c('before', 'after')))

# avg for 3 trts
bdr_avg4 <- left_join(bdr_avg4, select(bdr, fname, cop_name)%>%distinct())
bdr_avg4 <- left_join(bdr_avg4, select(infd, cop_name, trt))
bdr_avg4_inf <- ungroup(bdr_avg4)%>%
  group_by(trt,drop)%>%
  summarize(n = n(),
            avg_vel = median(avg_vel), 
            avg_vel_when_moving = median(avg_vel_when_moving, na.rm=T), 
            prop_moving = median(prop_moving),
            sd_vel = sd(avg_vel_when_moving, na.rm = T),
            sd_prop = sd(prop_moving, na.rm = T))

ggplot(filter(bdr_avg4, prop_moving > 0.0),
       aes(x = prop_moving, y = avg_vel_when_moving)) + 
  geom_point(alpha = 0.1) + geom_smooth() + 
  geom_point(data = bdr_avg4_inf, 
             aes(x = prop_moving, y = avg_vel_when_moving, color = trt),
             size = 5) +
  facet_grid(~drop) + 
  scale_y_log10() +
  labs(title = 'auto tracker', x = 'proportion moving', y = 'hop distance')
# tried adding error bars, but couldn't get them to look reasonable given skew in the data
```
```{r}
bd_avg4 <- filter(bd, time_sec < 59 | time_sec > 61, !is.na(dist))%>%
  mutate(drop = if_else(time_sec < 60, 'before', 'after'))%>%
  group_by(fname, drop)%>%
  summarise(n = n(), tot_dist = sum(dist), moving = sum(moving))%>%
  mutate(avg_vel = tot_dist/n, avg_vel_when_moving = tot_dist/moving, prop_moving = moving/n,
         drop = factor(drop, levels = c('before', 'after')))

bd_avg4$avg_vel_when_moving[which(is.infinite(bd_avg4$avg_vel_when_moving))]<-NA

bd_avg4 <- left_join(bd_avg4, select(bd, fname, cop_name)%>%distinct())
bd_avg4 <- left_join(bd_avg4, select(infd, cop_name, trt))

bd_avg4_inf <- ungroup(bd_avg4)%>%
  group_by(trt, drop)%>%
  summarize(avg_vel = mean(avg_vel), 
            avg_vel_when_moving = mean(avg_vel_when_moving, na.rm=T), 
            prop_moving = mean(prop_moving))

ggplot(filter(bd_avg4, prop_moving > 0.0),
       aes(x = prop_moving, y = avg_vel_when_moving)) + 
  geom_point(alpha = 0.1) + geom_smooth() + 
  geom_point(data = bd_avg4_inf, 
             aes(x = prop_moving, y = avg_vel_when_moving, color = trt),
             size = 5) +
  facet_grid(~drop) + 
  # scale_y_log10() +
  labs(title = 'manual tracking', x = 'proportion moving', y = 'hop distance')
```

Again, there are idiosyncratic differences between the datasets (like the aforementioned spurious combinations of large hops with little movement in the auto-tracking dataset). Nevertheless, the qualitative patterns appear similar in both datasets. The infecteds clearly spend less time moving than uninfecteds (shifted on the x-axis), but their hops are comparable (minimal shift along the y-axis). Additionally, response to the drop are subtle, suggesting copepods do not massively change how or how much they move in response to the 'shock'. Indeed, the time-series (plots above)[] suggest that on average they recover to pre-drop levels within a minute.

Here's another way to visualize treatment and drop effects in the two behavior variables. Until now, we have looked at averages across recordings and groups, ignoring how copepods respond to the drop within a recording. The next plots show how individuals respond to the drop, first for proportion of time moving. The overall averages are plotted in bold.

```{r}
ggplot(bdr_avg4, aes(x = drop, y = prop_moving, color = trt)) + 
  geom_line(aes(group = fname), alpha = 0.1) +
  geom_point(data = bdr_avg4_inf, aes(x = drop, y = prop_moving), size = 3) +
  geom_line(data = bdr_avg4_inf, aes(group = trt), size = 3) +
  facet_grid(~trt) +
  labs(title = 'auto tracker', y = 'proportion moving', color = 'treatment')
```
```{r}
ggplot(bd_avg4, aes(x = drop, y = prop_moving, color = trt)) + 
  geom_line(aes(group = fname), alpha = 0.05) +
  geom_point(data = bd_avg4_inf, aes(x = drop, y = prop_moving), size = 3) +
  geom_line(data = bd_avg4_inf, aes(group = trt), size = 3) +
  facet_grid(~trt) +
  labs(title = 'manual tracker', y = 'proportion moving', color = 'treatment')
```
The qualitative pattern is very similar in the two datasets - infecteds spend less time moving in general and all groups reduce activity after the drop. The values are higher in the manual data, but this makes sense given it's lower frame rate, i.e. more movement is possible within 2 seconds than an 1/8 of a second.

Making the same plot for our second response variable, hop distance...

```{r}
ggplot(bdr_avg4, aes(x = drop, y = avg_vel_when_moving, color = trt)) + 
  geom_line(aes(group = fname), alpha = 0.05) +
  geom_point(data = bdr_avg4_inf, aes(x = drop, y = avg_vel_when_moving), size = 3) +
  geom_line(data = bdr_avg4_inf, aes(group = trt), size = 3) +
  scale_y_log10() +
  facet_grid(~trt) +
  labs(title = 'auto tracker', y = 'hop distance', color = 'treatment')
```
```{r}
ggplot(bd_avg4, aes(x = drop, y = avg_vel_when_moving, color = trt)) + 
  geom_line(aes(group = fname), alpha = 0.05) +
  geom_point(data = bd_avg4_inf, aes(x = drop, y = avg_vel_when_moving), size = 3) +
  geom_line(data = bd_avg4_inf, aes(group = trt), size = 3) +
  facet_grid(~trt) +
  scale_y_log10() +
  labs(title = 'manual tracker', y = 'hop distance', color = 'treatment')
```

Here the pattern is a little differnt. In neither dataset is there much of a change due to the drop - copepod hops are of a similar magnitude before and after being frightened. Thus, the main response to the drop is fewer movements, not a change in the type of movements. In the manual dataset, the infecteds seem to have slightly smaller hops than uninifecteds, but this is not seen in the auto-tracked dataset.

We can also make these plots for average speed, the composite of time moving and hop distance.

```{r}
ggplot(bdr_avg4, aes(x = drop, y = avg_vel, color = trt)) + 
  geom_line(aes(group = fname), alpha = 0.05) +
  geom_point(data = bdr_avg4_inf, aes(x = drop, y = avg_vel), size = 3) +
  geom_line(data = bdr_avg4_inf, aes(group = trt), size = 3) +
  facet_grid(~trt) +
  labs(title = 'auto tracker', y = 'speed', color = 'treatment')
```
```{r}
ggplot(bd_avg4, aes(x = drop, y = avg_vel, color = trt)) + 
  geom_line(aes(group = fname), alpha = 0.05) +
  geom_point(data = bd_avg4_inf, aes(x = drop, y = avg_vel), size = 3) +
  geom_line(data = bd_avg4_inf, aes(group = trt), size = 3) +
  facet_grid(~trt) +
  labs(title = 'manual tracker', y = 'speed', color = 'treatment')
```

The pattern is quite similar in both datasets. Average speed decreases in response to the drop, particularly in the uninfected groups because they were more active to begin with. Infected copepods are less active regardless of whether they are observed before or after the drop.

To summarize, Infected copepods are spend less time moving than uninfected copepods, but when they are moving their 'hops' are of a similar magnitude. In response to the drop, copepods also reduce how often they move, but do not exhibit fundamentally different 'hops'.

Given these results, my preference is to simply use the composite measure for all further analyses. I have a couple justifications for this. First and foremost, hop distance seems neither impacted by infection nor the drop, so the variable does not obviously capture anything of biological importance. Second, analyzing multiple variables increases the opportunity for p-hacking and false positives, which is especially important when we get to the analysis of primary interest, comparing genotype by genotype interactions. Third, I could just use time moving as the response, as it is where infection and drop effects are most clearly seen. However, this would exclude all information on the distance copepods moved during the recording, which also seems to throw out a lot of information. The composite measure can be conveniently called 'activity' and expressed as either a distance or a speed.

One issue to address at the modelling phase is the unusual distribution of activity. Here it is at the frame level...

```{r}
# frame level
ggplot(bdr, aes(x = distance)) + 
  geom_histogram(binwidth = 0.1) +
  coord_cartesian(xlim = c(0,5))
```

...and here at the composite level of average activity across a recording.

```{r}
# composite level
ggplot(bdr_avg4, aes(x=tot_dist)) + 
  geom_histogram() + 
  facet_grid(~drop)
```




### Measure 3 - angle of movements

Another aspect of behavior that can be extracted from the recordings is the direction moved by copepods, like whether they moved forwards or backwards. I calculated the angle of movement between consecutive video frames.

```{r}
# calculate angle of movement for auto-tracked data
bdr <- mutate(bdr, x0 = lag(x), x2 = lead(x), y0 = lag(y), y2 = lead(y))%>%
    mutate(dist1 = sqrt((x0 - x)^2 + (y0 - y)^2) )%>%
    mutate(dist2 = sqrt((x - x2)^2 + (y - y2)^2) )%>%
    mutate(angle = acos(dot_product/(dist1 * dist2)) * 180/pi)%>%
    select(fname, frame, sec, x, y, blobs, blob_size, 
           distance, dot_product, angle)

# remove the angle calc for first observation in each recording
x <- group_by(bdr, fname)%>%
  summarize(frame_min = min(frame))%>%
  mutate(mv = paste(fname, frame_min))

bdr <- mutate(bdr, mv = paste(fname, frame))
bdr$angle[which(bdr$mv %in% x$mv)] <- NA
bdr <- select(bdr, -mv)
```

```{r}
# calculate angle of movement for manually-tracked data
bd <- mutate(bd, x0 = lag(x), x2 = lead(x), y0 = lag(y), y2 = lead(y))%>%
    mutate(dist1 = sqrt((x0 - x)^2 + (y0 - y)^2) )%>%
    mutate(dist2 = sqrt((x - x2)^2 + (y - y2)^2) )%>%
    mutate(dot_product = ((x2 - x) * (x - x0) + (y2 - y) * (y - y0)))%>%
    mutate(angle = acos(dot_product/(dist1 * dist2)) * 180/pi)%>%
    select(fname, day, slice, time_sec, x, y, 
           dist, dot_product, angle)

# remove the angle, dot_product calc for first observation in each recording
x <- group_by(bd, fname)%>%
  summarize(frame_min = min(slice))%>%
  mutate(mv = paste(fname, frame_min))
bd <- mutate(bd, mv = paste(fname, slice))
bd$angle[which(bd$mv %in% x$mv)] <- NA
bd$dot_product[which(bd$mv %in% x$mv)] <- NA
bd <- select(bd, -mv)
```

Here is the distribution of movement angles in both datasets.

```{r}
ggplot(bdr, aes(x = angle)) + geom_histogram(binwidth = 10) +
  labs(title = 'auto tracker')
```
```{r}
ggplot(bd, aes(x = angle)) + geom_histogram(binwidth = 10) +
  labs(title = 'manual tracking')
```

The distributions clearly differ; there are more forwards movements in the manual data and far more backwards movements in the auto data (angle values near 180). This is partly due to the different time scales of the datasets. The auto-tracking data recorded copepod position 8 times per second, and consequently there was a lot of opportunity for slight oscillations of the tracker back and forth (i.e. high angles). By contrast, copepod position was recorded once every two seconds in the manual dataset, so there should be less 'noise' oscillations. 

We can understand the difference between the datasets by plotting angle vs the distance moved.

```{r}
bdr <- mutate(bdr, group = if_else(sec < 58, 'before the drop', 
                         if_else(sec > 62, 'after the drop', 'drop')))

ggplot(filter(bdr, sec<58|sec>62)%>%sample_n(100000), 
       aes(x = angle, y = distance, color = group)) + 
  geom_point(alpha = 0.01) +
  geom_smooth(se=F) +
  scale_y_continuous(limits = c(0, 30)) +
  labs(title = 'auto tracking')
```

```{r}
bd <- mutate(bd, group = if_else(time_sec < 59, 'before the drop', 
                         if_else(time_sec > 61, 'after the drop', 'drop')))
ggplot(filter(bd, group != 'drop'), aes(x = angle, y = dist, color = group)) +
  geom_point(alpha = 0.01) + geom_smooth(se=F) +
  labs(title = 'manual tracking')
```

Forward movements (low angles) tend to be larger in both datasets. But in the auto-tracked dataset, there is an overabundance of backward movements, most of which are small, though some are large. Large backwards movements are tracking mistakes - the auto-tracker incorrectly jumps to one part of the well and then back again. I took steps to correct these mistakes (see [here](GITHUB)), but was perhaps too conservative in eliminating these kinds of movements. 

In neither dataset is there evidence that the drop markedly changed the directions moved. Copepods do not more often move backwards or in a zig-zag pattern for instance. We can also visualize this by plotting average movement direction over the recording.

```{r}
bdr_avg <- group_by(bdr, sec)%>%
  summarize(mean_dir = mean(angle, na.rm = T),
            var_dir = var(angle, na.rm = T))%>%
  mutate(group = if_else(sec < 58.5, 'before the drop', 
                         if_else(sec > 61.5, 'after the drop', 'drop')))

ggplot(bdr_avg, aes(x = sec, y = mean_dir)) + 
  geom_path() + geom_point(aes(color=group)) +
  scale_x_continuous(limits = c(0,120), breaks = seq(0, 120, by = 10)) +
  labs(title = 'angle - auto tracker')
```
```{r}
bd_avg <- group_by(bd, time_sec)%>%
  summarize(mean_dir = mean(angle, na.rm=T),
            var_dir = var(angle, na.rm=T))%>%
  mutate(group = if_else(time_sec < 59, 'before the drop', 
                         if_else(time_sec > 62, 'after the drop', 'drop')))

ggplot(bd_avg, aes(x = time_sec, y = mean_dir)) + 
  geom_path() + geom_point(aes(color=group)) +
  scale_x_continuous(limits = c(0,120), breaks = seq(0, 120, by = 10)) +
  labs(title = 'angle - manual tracker')
```

The difference in the mean movement angle is obvious in the two datasets. The lower value in the manually-tracked data corresponds closely to typical copepod movements along the edge of the circular well. The drop induces changes in opposite directions in the two datasets. The auto-tracker 'resets' at the drop (i.e. background subtraction of the video frames starts over), so it may not spot the copepod immediately. Once it is tracking something, the small back-and-forth oscillations then dominate and determine the mean values. In the manual dataset, the increase in angle values right after the drop could indicate more sideways or backwards movement by copepods, but this should not be over-interpreted because this was also where copepods moved the least. One consistent feature of both datasets: angle values return to 'pre-drop' levels very quickly, suggesting the kinds of movements made by copepods was not fundamentally altered by this shock.

Given that (i) the auto-tracker seems to introduce a lot of noise into this variable measure and (ii) there is not an obvious response to the drop, further evaluation of this variable may not be worthwhile. But before ignoring it, I want to check whether movement angles differs between infected and uninfected copepods.

```{r}
bdr <- mutate(bdr, cop_name = substring(fname, 1, 5))%>%
  mutate(dist_cat = cut(distance, breaks = c(0, 0.5, 2, 7)))

bd_i <- left_join(bdr, infd, by = 'cop_name')

ggplot(filter(bd_i, group != 'drop'),
       aes(y = angle, x = trt2)) +
  geom_boxplot() +
  labs(title = 'auto tracking - facetted by movement distance', x = 'treatment') +
  facet_grid(group~dist_cat)
```

```{r}
bd <- mutate(bd, cop_name = substring(fname, 1, 5))%>%
  mutate(dist_cat = cut(dist, breaks = c(0, 0.5, 2, 7)))
bd_i <- left_join(bd, infd, by = 'cop_name')

ggplot(filter(bd_i, group != 'drop'),
       aes(y = angle, x = trt2)) +
  geom_boxplot() +
  labs(title = 'manual tracking - facetted by movement distance', x = 'treatment') +
  facet_grid(group~dist_cat)
```

There is no conspicuous difference between treatments in either dataset, regardless of whether movements are large or small or whether they were before or after the drop. A similar way to assess this by calculating dot products for movements. The dot product of two vectors combines information about vector magnitudes and directions into a single value. [Elsewhere](GITHUB) I compared dot products among treatments and found that they do not differ. Thus, for simplicity I will only consider the movement distance from this point forward.


## Simplifying behavioral measurements

Now, I explore ways to justifiably simplify our response variable.

### Reducing the frame rate

Previous studies recorded copepods at 1 frame per 2 sec (LINKS!!)[XXX], which preliminary experiments determined was optimal for manual tracking - only a small number of frames needed to be clicked through and it did not miss much movement. By comparison, the auto tracker used 8 frames/sec, a frame rate 16 times higher. This high rate was used because each frame helped establish the recording's 'background', which was then subtracted out to detect movement from one frame to the next. Recording a copepod's position every 1/8 of a second is presumably overkill; it probably detects superfluous movements and creates an unnecessarily large dataset. But how much should we reduce the frame rate? To evaluate this, for several frame rates I averaged copepod position across the frames to be pooled and then recalculated the distance moved between frames. To compare different frame rates, I summed the total distance moved during the recording - if much information is lost with lower frame rates, the total distance moved should diverge from that using the full set of frames.

```{r}
# reduce the data frame to different frame rates...
# get cop position and distance for 1 frame per 4 s - less than even manual rate
bdr_1per4s <- mutate(bdr, fg = cut(sec, 30))%>%
  group_by(fname, fg)%>%
  summarize(x = mean(x), y = mean(y))%>%
  mutate(x0 = lag(x), y0 = lag(y))%>%
  mutate(dist = sqrt((x0 - x)^2 + (y0 - y)^2))%>%
  select(fname, fg, dist)

# get cop position and distance for 1 frame per 2 s
bdr_1per2s <- mutate(bdr, fg = cut(sec, 60))%>%
  group_by(fname, fg)%>%
  summarize(x = mean(x), y = mean(y))%>%
  mutate(x0 = lag(x), y0 = lag(y))%>%
  mutate(dist = sqrt((x0 - x)^2 + (y0 - y)^2))%>%
  select(fname, fg, dist)

# for 1 frames per s
bdr_1pers <- mutate(bdr, fg = cut(sec, 120))%>%
  group_by(fname, fg)%>%
  summarize(x = mean(x), y = mean(y))%>%
  mutate(x0 = lag(x), y0 = lag(y))%>%
  mutate(dist = sqrt((x0 - x)^2 + (y0 - y)^2))%>%
  select(fname, fg, dist)

# for 2 frames per s
bdr_2pers <- mutate(bdr, fg = cut(sec, 240))%>%
  group_by(fname, fg)%>%
  summarize(x = mean(x), y = mean(y))%>%
  mutate(x0 = lag(x), y0 = lag(y))%>%
  mutate(dist = sqrt((x0 - x)^2 + (y0 - y)^2))%>%
  select(fname, fg, dist)

# for 4 frames per s
bdr_4pers <- mutate(bdr, fg = cut(sec, 480))%>%
  group_by(fname, fg)%>%
  summarize(x = mean(x), y = mean(y))%>%
  mutate(x0 = lag(x), y0 = lag(y))%>%
  mutate(dist = sqrt((x0 - x)^2 + (y0 - y)^2))%>%
  select(fname, fg, dist)
```

```{r}
# calc tot distance moved over recording in auto-tracked data at diff frame rates
bdr_td <- group_by(bdr, fname)%>%
  summarize(dist_full = sum(distance, na.rm = T))

bdr_td_1per4s <- group_by(bdr_1per4s, fname)%>%
  summarize(dist_1per4s = sum(dist, na.rm = T))

bdr_td_1per2s <- group_by(bdr_1per2s, fname)%>%
  summarize(dist_1per2s = sum(dist, na.rm = T))

bdr_td_1pers <- group_by(bdr_1pers, fname)%>%
  summarize(dist_1pers = sum(dist, na.rm = T))

bdr_td_2pers <- group_by(bdr_2pers, fname)%>%
  summarize(dist_2pers = sum(dist, na.rm = T))

bdr_td_4pers <- group_by(bdr_4pers, fname)%>%
  summarize(dist_4pers = sum(dist, na.rm = T))

# combine for plotting
bdr_comp <- left_join(bdr_td, bdr_td_1per4s)
bdr_comp <- left_join(bdr_comp, bdr_td_1per2s)
bdr_comp <- left_join(bdr_comp, bdr_td_1pers)
bdr_comp <- left_join(bdr_comp, bdr_td_2pers)
bdr_comp <- left_join(bdr_comp, bdr_td_4pers)
```

As expected, the correlation (r^2^ on the y-axis below) between the full dataset and the reduced datasets decreases as the frame rate is reduced. However, even when the frame rate is reduced 8x (1 per sec), r^2^ is still quite high at 0.9, indicating that we are not losing much information on copepod movement. And some of the lost information might be random noise, i.e. the tiny oscillations between frames that are averaged out at lower frame rates.

```{r}
ctab <- cor(select(bdr_comp, -fname), use = "pairwise.complete.obs")

fr = c(8, 0.25, 0.5, 1, 2, 4)

cor_plot <- data.frame(frame_rate = fr,
                       frames_per_rec = fr * 120,
                       r2 = ctab[1,]^2)
                    
ggplot(cor_plot, aes(x = frame_rate, y = r2)) + geom_point() + geom_line() +
  scale_x_reverse()
```

Subjectively, a frame rate of 2 per second seems like a reasonable compromise. It reduces the auto-tracked data 4 fold, while retaining much of the information (r^2^ = 0.93). Conversely, compared to the manually-tracked data, this retains 4x more data on copepod position, though as mentioned before, previous work did not indicate a lot of information gain through a frame rate higher than 1 per 2 seconds. In the end, the reduction in frame rate is a practical decision, unlikely to bias or gloss over differences between treatments.

```{r}
# remove unneeded data frames
rm(list = ls(pattern = "bdr_td"))
rm(list = ls(pattern = "bdr_1p"))
rm(bdr_comp, cor_plot, ctab, fr, bdr_4pers)
```

### Categorizing sections of the recording

Conducting analyses at the level of each video frame (i.e. each copepod movement) seems like overkill, e.g. the auto-tracked data at 8 frames/s has several million observations. And there is substantial pseudoreplication - within a recording observations are separated by milliseconds and thus presumably highly-correlated. It would be nice to take one or a few composite variables from each recording that summarize copepod behavior. To do this, though, we need to closely examine how behavior changes within a recording so as not to average out any potentially interesting variation. At a minimum we can define two parts expected to differ: before and after the drop. 

Let's re-plot how average behavior changes over a recording, this time with confidence intervals (they are underestimated, as I have not accounted for pseudoreplication; each copepod was recorded multiple times).

```{r}
bdr <- mutate(bdr, sec_pooled = cut(sec, breaks = seq(0, 120, 2), include.lowest = T))
bdr_avg <- group_by(bdr, sec_pooled, group)%>%
  summarize(mean_dist = mean(distance, na.rm=T),
            sd_dist = sd(distance, na.rm = T),
            n = n())%>%
  mutate(se = sd_dist/sqrt(n))%>%
  mutate(uci = mean_dist + 2.6*se,
         lci = mean_dist - 2.6*se)
```
```{r}
ggplot(filter(bdr_avg, group != 'drop'),
       aes(x = sec_pooled, y = mean_dist, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin = lci, ymax = uci)) + 
  labs(title = 'auto tracker - 99% CIs')
```


```{r}
bd_avg <- group_by(bd, time_sec)%>%
  summarize(mean_dist = mean(dist, na.rm=T),
            sd_dist = sd(dist, na.rm = T),
            n = n())%>%
  mutate(se = sd_dist/sqrt(n))%>%
  mutate(uci = mean_dist + 2.6*se,
         lci = mean_dist - 2.6*se)%>%
  mutate(group = if_else(time_sec < 59, 'before the drop', 
                         if_else(time_sec > 62, 'after the drop', 'drop')))
```
```{r}
ggplot(filter(bd_avg, group != 'drop', time_sec != -2),
       aes(x = time_sec, y = mean_dist, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin = lci, ymax = uci)) +
  labs(title = 'manual tracker - 99% CIs')
```

The pattern is broadly similar in both dataset; a decrease in activity after the drop, followed by a steady recovery in activity, which is perhaps a bit faster in the manual data. There is some suspicious variation in the auto-tracker - low values at the start of the recording and high values right before the drop - which do not appear in the manual dataset. What sections of the recording can we pool together to both capture this temporal variation and simplify analyses?

There is not an obvious biological reason to split the 'before' group, given that it experiences constant conditions. Perhaps it could be split to account for technical variation, such as the slightly lower activity levels at the beginning of the recording (presumably due to the copepod not being tracked right away - it needs to be spotted before it can be followed). The 'after' group could be split to account for the recovery over time, such as into a 'shocked' and 'recovering' phase, or even into three groups ('shocked', 'recovering', and 'recovered'). Let's see what that looks like.

```{r}
bdr_avg$sec <- seq(0, 120, 2)
bdr_avg <- mutate(bdr_avg, group2 = if_else(group == 'before the drop', 'before', 
                                    if_else(sec>61.5 & sec<=80, 'shocked', 
                                            if_else(sec>80 & sec<100, 'recovering', 'recovered'))))
```
```{r}
ggplot(filter(bdr_avg, group != 'drop'),
       aes(x = sec_pooled, y = mean_dist, color = group2)) +
  geom_point() +
  geom_errorbar(aes(ymin = lci, ymax = uci)) + 
  labs(title = 'auto tracker - 99% CIs')
```

```{r}
bd_avg <- mutate(bd_avg, group2 = if_else(group == 'before the drop', 'before', 
                                          if_else(time_sec>61.5 & time_sec<=80, 'shocked', 
                                            if_else(time_sec>80 & time_sec<100, 'recovering', 'recovered'))))
```
```{r}
ggplot(filter(bd_avg, group != 'drop', time_sec != -2),
       aes(x = time_sec, y = mean_dist, color = group2)) +
  geom_point() +
  geom_errorbar(aes(ymin = lci, ymax = uci)) +
  labs(title = 'manual tracker - 99% CIs')
```

Obviously, there is still some variation within these groups, particularly the 'shocked' group. To get an idea about how adequate these categories are, I fit simple linear models using different groupings and looked at the variance explained. The simplest categorization is just before vs after. Then, I separate the after period into two 30s intervals, and then into three 20s intervals. Finally, we consider a factor for every two seconds of observation (presumably overkill).








```{r}
# auto data - model comp
bdr <- mutate(bdr, group2 = if_else(group == 'before the drop', 'before', 
                                    if_else(sec>61.5 & sec<=90, 'recovery', 'recovered')),
              group3 = if_else(group == 'before the drop', 'before', 
                                    if_else(sec>61.5 & sec<=80, 'shocked',
                                            if_else(sec>80 & sec<=100, 'recovering', 'recovered')))
              )

lm0 <- lm(distance ~ factor(sec_pooled), filter(bdr, group != 'drop'))
lm1 <- lm(distance ~ group3, filter(bdr, group != 'drop'))
lm2 <- lm(distance ~ group2, filter(bdr, group != 'drop'))
lm3 <- lm(distance ~ group, filter(bdr, group != 'drop'))
lm4 <- lm(distance ~ 1, filter(bdr, group != 'drop'))
anova(lm4, lm3, lm2, lm1, lm0)

# make plot of r2
dx <- data.frame(r2 = c(summary(lm4)$r.squared,
        summary(lm3)$r.squared,
        summary(lm2)$r.squared,
        summary(lm1)$r.squared,
        summary(lm0)$r.squared),
        df = c(summary(lm4)$df[1],
        summary(lm3)$df[1],
        summary(lm2)$df[1],
        summary(lm1)$df[1],
        summary(lm0)$df[1]),
        trt = factor(c("int-only", "bef-aft", "bef-2 groups", "bef-3 groups", "2 sec"),
                     levels = c("int-only", "bef-aft", "bef-2 groups", "bef-3 groups", "2 sec"))
        )

ggplot(dx, aes(x = trt, y = r2, size = df)) + geom_point() + geom_label(aes(label = df))
```

```{r}
# manual data - model comp
bd <- mutate(bd, group2 = if_else(group == 'before the drop', 'before', 
                                    if_else(time_sec>61.5 & time_sec<=90, 'recovery', 'recovered')),
              group3 = if_else(group == 'before the drop', 'before', 
                                    if_else(time_sec>61.5 & time_sec<=80, 'shocked',
                                            if_else(time_sec>80 & time_sec<=100, 'recovering', 'recovered')))
              )

lm0 <- lm(dist ~ factor(time_sec), filter(bd, group != 'drop', time_sec != -2))
lm1 <- lm(dist ~ group3, filter(bd, group != 'drop', time_sec != -2))
lm2 <- lm(dist ~ group2, filter(bd, group != 'drop', time_sec != -2))
lm3 <- lm(dist ~ group, filter(bd, group != 'drop', time_sec != -2))
lm4 <- lm(dist ~ 1, filter(bd, group != 'drop', time_sec != -2))
anova(lm4, lm3, lm2, lm1, lm0)


# make plot of r2
dx <- data.frame(r2 = c(summary(lm4)$r.squared,
        summary(lm3)$r.squared,
        summary(lm2)$r.squared,
        summary(lm1)$r.squared,
        summary(lm0)$r.squared),
        df = c(summary(lm4)$df[1],
        summary(lm3)$df[1],
        summary(lm2)$df[1],
        summary(lm1)$df[1],
        summary(lm0)$df[1]),
        trt = factor(c("int-only", "bef-aft", "bef-2 groups", "bef-3 groups", "2 sec"),
                     levels = c("int-only", "bef-aft", "bef-2 groups", "bef-3 groups", "2 sec"))
        )

ggplot(dx, aes(x = trt, y = r2, size = df)) + geom_point() + geom_label(aes(label = df))

```

The variance explained by different categorizations is similar in the two datasets. The be

```{r}
# make different cut points
bs<-seq(2, 60, by = 2)
for(b in bs){
  # print(b)
  bd <- mutate(bd, secx = cut(time_sec, breaks = b))
  
  lmx <- lm(dist ~ secx, filter(bd, group != 'drop', time_sec != -2))
  df <- summary(lmx)$df[1]
  r2 <- summary(lmx)$r.squared
  
  if(b == 2) {
    dx <- data.frame( df = df, r2 = r2)
  } else {
    dxx <- data.frame( df = df, r2 = r2)
    dx <- rbind(dx, dxx)
    rm(dxx)
  }
  
}
```
Funky looking because of how groups are made...
```{r}
ggplot(dx, aes(x = df, y = r2)) + geom_point()
```

```{r}
x
```

```{r}
y
```



```{r}
bd_i <- mutate(bd_i, sec_pooled = cut(sec, breaks = seq(0, 120, 2), include.lowest = T))
bdr_avg <- group_by(bd_i, sec_pooled, trt2)%>%
  summarize(mean_dist = mean(distance, na.rm=T),
            sd_dist = sd(distance, na.rm = T),
            n = n())%>%
  mutate(se = sd_dist/sqrt(n))%>%
  mutate(uci = mean_dist + 1.96*se,
         lci = mean_dist - 1.96*se)
```

```{r}
ggplot(filter(bdr_avg),
       aes(x = sec_pooled, y = mean_dist, color = trt2)) +
  geom_point() +
  geom_errorbar(aes(ymin = lci, ymax = uci)) + coord_cartesian(ylim = c(0, 1.5))
```










```{r}
bdr_avg <- filter(bdr, group != 'drop')%>%
  group_by(fname, group)%>%
  summarize(avg_dist = mean(distance, na.rm=T))%>%
  mutate(group = factor(group, levels = c("before the drop", "after the drop")))
```
```{r}
ggplot(bdr_avg, aes(x = avg_dist)) + geom_histogram()
ggplot(bdr_avg, aes(x = log(avg_dist))) + geom_histogram()
```

```{r}
ggplot(bdr_avg, aes(x = group, y = avg_dist)) +
  geom_line(aes(group = fname), alpha = 0.05) + geom_point(alpha = 0.1)
```


```{r}
bdr_avg <- mutate(bdr_avg, cop_name = substring(fname, 1, 5))
bdr_avg <- left_join(bdr_avg, select(infd, cop_name, trt2))
```

```{r}
ggplot(bdr_avg, aes(x = group, y = avg_dist)) + geom_boxplot() + facet_grid(~trt2)
```












# Exploratory Analyses

Make graph comparing treatments.

```{r message=FALSE, warning=FALSE}
bd_avg <- group_by(bd, time_sec, trt)%>%
  summarize(dista = mean(dist, na.rm=T))

ggplot(bd_avg, aes(x = time_sec, y = dista, color = trt)) +
  geom_line()
```

The infected copepods are less active than the uninfected copepods. This is true both before and after the simulated attack. When we separate this plot into the different days of the experiment, we see a similar pattern. Maybe at the earliest time point, day 5, the infected copepods are less manipulated.

```{r}
bd_avg <- group_by(bd, time_sec, day, trt)%>%
  summarize(dista = mean(dist, na.rm=T))

ggplot(bd_avg, aes(x = time_sec, y = dista, color = trt)) +
  geom_line() +
  facet_wrap(~day)
```

Now, let's look at the pattern for just the uninfected copepods, separated by copepod family. They seem pretty similar, thought one family (III) might be a little more active in general.

```{r}
bd_avg <- filter(bd, trt != 'infected')%>%
  group_by(time_sec, cop_fam)%>%
  summarize(dista = mean(dist, na.rm=T))

ggplot(bd_avg, aes(x = time_sec, y = dista, color = cop_fam)) +
  geom_line() 
```

Now, separate the data by parasite family. The differences appear reasonably consistent, suggesting parasite family is more important than host family.

```{r}
bd_avg <- filter(bd, trt == 'infected')%>%
  group_by(time_sec, parasite_fam)%>%
  summarize(dista = mean(dist, na.rm=T))

ggplot(bd_avg, aes(x = time_sec, y = dista, color = parasite_fam)) +
  geom_line() 
```

Here is the combo of host and parasite genotypes.

```{r}
bd_avg <- filter(bd, trt == 'infected')%>%
  group_by(cop_fam, parasite_fam)%>%
  summarize(dista = mean(dist, na.rm=T))

ggplot(bd_avg, aes(x = parasite_fam, y = dista, color = cop_fam)) +
  geom_line(aes(group = cop_fam))
```

# Models

```{r}
library(lme4)

# null model
out0 <- lmer(dist ~ factor(day) + (1|fname) + (1|cop_name), filter(bd, trt == 'infected'))

# add cop_fam to null
outc <- lmer(dist ~ cop_fam + factor(day) + (1|fname) + (1|cop_name), filter(bd, trt == 'infected'))
anova(out0, outc, test = 'Chi')

# add parasite_fam to null
outp <- lmer(dist ~ parasite_fam + factor(day) + (1|fname) + (1|cop_name), filter(bd, trt == 'infected'))
anova(out0, outp, test = 'Chi')

# add cop x parasite to null
outcp <- lmer(dist ~ cop_fam * parasite_fam + factor(day) + (1|fname) + (1|cop_name), filter(bd, trt == 'infected'))
anova(outc, outcp, test = 'Chi')
anova(outp, outcp, test = 'Chi')
```

GxG!!! Awesome!!


```{r}
sort(table(bd$dist), decreasing = T)
qplot(data = filter(bd, dist > 0), x = dist, binwidth = 0.1) 
#+ coord_cartesian(xlim = c(0, 0.5))
```

