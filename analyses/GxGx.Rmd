---
title: "Genotype x genotype interactions in host manipulation"
author: "Dan Benesh"
output: html_document
---

```{r setup, include=FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
options(stringsAsFactors = FALSE)
theme_set(new = theme_bw())
```

# Experiment Background
Many parasites manipulate the behavior of their hosts in ways that seem beneficial. Little is known about genetic variation in this phenotype. Are parasites genetically variable in how much they manipulate host behavior? Do different host genotypes resist manipulation better than others? I infected 5 host strains with 5 parasite strains to quantify the variability in host manipulation due to parasite genes, host genes, and their interactions. The host-parasite system I used was the tapeworm *Schistocephalus solidus* in its copepod first intermediate host.

```{r importdata}
# import data
bd <- read.csv(file = "../data/behav_combined_after_qc2.csv", header = TRUE) # manual data
bdr <- read.csv(file = "../data/behav_combined_auto_tracked_corrected.csv", header = TRUE) # auto-tracked data
infd <- read.csv(file = "../data/GxG_inf.csv", header = TRUE, fileEncoding = "UTF-8-BOM") #excel attached BOM to csv
```

Copepod movement was video recorded for two minutes. After one minute, the well plate containing the copepods was dropped in a standardized way to simulate a predator attack and 'frighten' the copepods. Each copepod was recorded on several days throughout the course of parasite development (from uninfective to infective larva). 

Recordings were both manually- (clicking on copepod position frame-by-frame) and automatically-processed (with a tracking program). The output from the two approaches was quite similar (see an extensive comparison [here](GITHUB LINK!!)). Each approach has some advantages and disadvantages. First of all, I identified mistakes in the manually-processed data, like incorrect number of frames, etc. (see [here](GITHUB LINK)); this human error motivated the development of an auto-tracker. The auto-tracker allowed additional videos and copepods to be processed that were not included in the manual data for lack of time. However, the auto-tracker was also not free from mistakes, occassionally recording large movements that were not. Here I make sure that both datasets yield concordant results.

In this notebook, I first present descriptive statistics from the experiment. Then, I look at ways of quantifying behavior and defining the response variable. Next, I conduct exploratory analyses of the factors impacting the response variable. Finally, I fit models to test the hypothesis of genotype-by-genotype interactions.

```{r}
# Select and rename columns
bd <- select(bd, fname, cop_name, day, 
             slice = Slice.n., x = X, y = Y,
             dist = Distance, pixel = Pixel.Value, 
             ok_col_names, ok_col_num, ok_row_num)%>%
  arrange(day, cop_name, slice)

# for first observation of every video, no 'distance moved' can be calculated; replace with NA
bd$dist[bd$slice == 1 & bd$dist == -1] <- NA

# create new variables
bd <- mutate(bd, time_sec = slice * 2 - 4)

# make fname consistent with auto-tracked file
bd <- mutate(bd, fname = if_else(day > 10, paste0(cop_name, "_", day),
                          paste0(cop_name, "_0", day)))
```

# Descriptive Statistics

Let's look at some basic stats. How many copepods were in the experiment?

```{r}
# correct problem from import with `cop_name` column
if(grepl(pattern = "?..", names(infd)[1])) { # if first column name has weird '?..' after import...
  names(infd)[1] <- 'cop_name' # change it
} 

# create new trt var with unexposed and uninfecteds pooled
infd$trt2 <- infd$trt
infd$trt2[which(infd$infected == 0)] <- 'uninfected'
```
```{r}
sum(!is.na(infd$exposed)) # if included, cops had a value for 'exposed' variable
```

How many were exposed to infection?

```{r}
sum(infd$exposed == 1, na.rm=T)
```

The rest were unexposed controls (n = `r sum( infd$exposed == 0, na.rm=T)`).

Whether copepods were infected or not was checked after a week. How many survived until being checked for infection?

```{r}
sum( !is.na(infd$infected) )
```

And how many were infected?

```{r}
sum(infd$infected == 1, na.rm=T)
```

So the infection rate was `r round(sum(infd$infected == 1, na.rm=T) / sum( infd$exposed == 1, na.rm=T), 3) * 100`%.

We can also do some quality control checks on our infection data. For example, I measured some parasite traits like cercomere presence (an indication of developmental rate) and worm size. So we can check to make sure these variables are only recorded from infected copepods, starting with cercomere presence. 

It is, though 5 infected copepods are missing cercomere data.
```{r}
table(!is.na(infd$cerc_d9), infd$trt)
```

Similarly, worm size was only recorded from infected copepods, though in 99 it was not measured. Most of those without size measurement died before the end of the experiment 21 days post exposure.

```{r}
table(!is.na(infd$proc_size1), infd$trt)
```

Worm size was measured twice. The two measures are highly correlated, with a pearson correlation coefficient of `r round( with(infd, cor(proc_size1, proc_size2, use = "pairwise")), 2)`, though there was some variation in the measurements.

```{r message=FALSE, warning=FALSE}
qplot(data = infd, x = proc_size1, y = proc_size2) + theme_bw()
```

Presumably, this is normal measurement error due to e.g. photo angles, moving worms, etc. The average of the two body size measurements is taken as the best measure of larval size in future analyses.

```{r}
infd <- mutate(infd, proca = (proc_size1 + proc_size2)/2) # average of 2 proc measurements
```

Moving on to the behavior data, how many copepods had their behavior recorded manually?

```{r}
bd_cops <- unique(bd$cop_name)
length(bd_cops)
```

How many were recorded automatically?

```{r}
bdr <- mutate(bdr, cop_name = substr(fname, 1, 5))
bd_cops <- unique((bdr$cop_name))
length(bd_cops)
```

There are 5 cop families and 5 parasite families. How many infected cops are in each group?

```{r}
# reduce infection df to just infected cops with manual behav measurements, make table
t <- with(filter(infd, cop_name %in% bd$cop_name, trt2 == 'infected'),
     table(cop_fam, parasite_fam))
t
```

It ranges from `r min(t)` to `r max(t)` per combination, with an average of `r mean(t)`. This is the same for both auto- and manually-tracked behavior data, as all infecteds but not all uninfecteds were tracked.

What about uninfecteds? Let's check the numbers of unexposed controls and exposed-but-uninfected copepods in each copepod family. Generally about 30 per family in the manually-tracked data.

```{r}
# reduce infection df to just uninfected cops with manual behav measurements, make table
t <- with(filter(infd, cop_name %in% bd$cop_name, infected == 0),
     table(cop_fam, trt))
t
```

In the auto-tracked data, additional exposed-but-uninfected copepods were tracked with the auto-tracker. This should provide a better baseline for the behavior of uninfected copepods in each family.

```{r}
# Auto tracked table of uninfecteds
t <- with(filter(infd, cop_name %in% bdr$cop_name, infected == 0),
     table(cop_fam, trt))
t
```

Each copepod was observed on multiple days over the course of the experiment. In the manual dataset, how many times were copepods observed on average?

```{r}
# manual data
n_rec <- select(bd, cop_name, day)%>%distinct()%>%group_by(cop_name)%>%summarize(n_rec = n())
n_rec <- left_join(n_rec, select(infd, cop_name, trt))
tapply(n_rec$n_rec, n_rec$trt, mean)
# round(prop.table(table(n_rec$trt, n_rec$n_rec), margin = 1), 2)
```

In each treatment group, there were nearly 7 observations per copepod, corresponding to days 5, 7, 9, 11, 13, 15, and 17 post-infection. Sometimes, copepods died before the end of the experiment, which is why there were fewer observations for some individuals. What about the auto-tracking data?

```{r}
# auto data
bdr <- mutate(bdr, day = substr(fname, start = 7, stop = 8))
n_rec <- select(bdr, cop_name, day)%>%distinct()%>%group_by(cop_name)%>%summarize(n_rec = n())
n_rec <- left_join(n_rec, select(infd, cop_name, trt))
tapply(n_rec$n_rec, n_rec$trt, mean)
# round(prop.table(table(n_rec$trt, n_rec$n_rec), margin = 1), 2)
```

The average number of recordings processed increased to over 8 per copepod. This is because I used the auto-tracker to process additional videos taken at days 19 and 21 postinfection that were not previously manually-processed.

# Define Response Variables

What measures of copepod behavior should we extract from the videos? What should be our response variable? How can we simplify the very fine frame-by-frame data to something more manageable and understandable? First, I examine the utility of different measures of copepod behavior. Second, I check ways to simplify the measurements to ease modelling and improve understanding.

## Behavioral measures
### Speed

The simplest measurement is the distance moved between frames. We can also call this copepod's speed, given that it is a distance moved in a defined time. Behavior was filmed over two minutes, with the plate being dropped in the middle of the recording. So *a priori* we can divide a recording into three sections: before the drop, during the drop, and after the drop.  Let's see how average speed changes throughout a recording.

```{r}
bdr_avg <- group_by(bdr, sec)%>%
  summarize(mean_dist = mean(distance, na.rm = T),
            mean_dp = mean(dot_product, na.rm = T))%>%
  mutate(group = if_else(sec < 58.5, 'before the drop', 
                         if_else(sec > 61.5, 'after the drop', 'drop')))

ggplot(bdr_avg, aes(x = sec, y = mean_dist)) + 
  geom_path() + geom_point(aes(color=group)) +
  scale_x_continuous(limits = c(0,120), breaks = seq(0, 120, by = 10)) +
  labs(title = 'auto tracker, 8 frames/s', color = 'section', x = 'seconds', y = 'speed')
```
```{r warning=FALSE}
bd_avg <- group_by(bd, time_sec)%>%
  summarize(mean_dist = mean(dist, na.rm=T))%>%
  mutate(group = if_else(time_sec < 59, 'before the drop', 
                         if_else(time_sec > 62, 'after the drop', 'drop')))
  
ggplot(bd_avg, aes(x = time_sec, y = mean_dist)) + 
  geom_path() + geom_point(aes(color=group)) +
  scale_x_continuous(limits = c(0,120), breaks = seq(0, 120, by = 10)) +
  labs(title = 'manual tracker, 1 frame/2 s', color = 'section', x = 'seconds', y = 'speed')
```

The most conspicuous pattern is the spike at 60 second during the drop. In fact, the copepod moves so fast during this drop that it cannot be reliably tracked, even at the high frame rate of an 8/second. The slight change in plate position through the drop also causes problems with background subtraction in the auto-tracking program. The values during the plate drop cannot be considered accurate and need to be removed before analyses. But how much should we remove on either side of the drop? 

Let's zoom in on the drop. Just eyeballing it, it seems like taking the 1.5 seconds on either side of the drop seems to reasonably exclude most of the peak.

```{r}
ggplot(bdr_avg, aes(x = sec, y = mean_dist)) + 
  geom_path() + geom_point(aes(color=group)) +
  labs(title = 'auto tracker, 8 frames/s', x = 'seconds', y = 'speed') + 
  scale_y_log10() + coord_cartesian(xlim = c(50, 70))
```

When we exclude the data around the drop, we see more clearly how copepods respond. 

```{r}
ggplot(filter(bdr_avg, group != 'drop'), 
       aes(x = sec, y = mean_dist, color = group)) + 
  geom_path() + 
  scale_x_continuous(limits = c(0,120), breaks = seq(0, 120, by = 10)) +
  labs(title = 'auto tracker, 8 frames/s', x = 'seconds', y = 'speed')
```
```{r}
ggplot(filter(bd_avg, group != 'drop'), 
       aes(x = time_sec, y = mean_dist, color = group)) + 
  geom_path() + 
  scale_x_continuous(limits = c(0,120), breaks = seq(0, 120, by = 10)) +
  labs(title = 'manual tracking', x = 'seconds', y = 'speed')
```

There is a clear decrease in activity directly after the drop, but the copepods seem to recover rather quickly so that by the end of the recording their activity levels have recovered. Also, in the auto-tracked data, there is still a spike shortly before the drop, which was not observed in the manual data. I think this represents a problem with how background subtraction works at the 'edges' of the video (i.e. before and after the drop). Presumably, this is random error and it shouldn't bias treatment differences, but it might be worth excluding a little more than 1.5 seconds on both sides of the drop.

### Proportion of time moving vs distance moved

Instead of asking how far/fast a copepod moved in a given time frame, we can ask if it was moving at all. This may provide some additional nuance, because a copepod can move the same distance over a recodring in different ways, e.g. steady, slow movements vs. a few large, fast movements. Previous studies (LINK!!!)[] using the same recording approach have examined two behavior variables: i) whether a copepod was moving and ii) if yes, how fast/far it was moving. These two behavioral variables are components of the 'speed' measure used above, but let's separate them to see if it adds any information. In particular, we are interested in how they are affected by infection.

```{r}
# tag frames where cop not-moving
# auto
bdr <- mutate(bdr, moving = if_else(distance < 0.13, 0, 1))
# manual
bd <- mutate(bd, moving = if_else(dist < 0.13, 0, 1))
# value of 0.13 was used as cutoff to designate non-moving tiny oscillattions, because it represented a one pixel move in the manual data, which is presumably due to clicking in a slightly different spot than a genuine change in copepod position
```

We can plot how both variables from both datasets vary over the recording period, starting with whether copepods were moving or not.

```{r}
# plot over time for auto tracker
bdr_avg2 <- filter(bdr, !is.na(moving))%>%
  group_by(sec)%>%
  summarise(moving = sum(moving, na.rm = T) , n = n())%>%
  mutate(prop_moving = moving/n, 
         group = if_else(sec < 58.5, 'before the drop', if_else(sec > 61.5, 'after the drop', 'drop')))

ggplot(bdr_avg2, aes(x = sec, y = prop_moving)) + 
  geom_line() +
  geom_point(aes(color = group)) +
  labs(title = 'auto tracker', x = 'seconds', y = 'proportion moving') +
  scale_y_continuous(limits = c(0,1))
```
```{r}
# plot over time for manual tracking
bd_avg2 <- filter(bd, !is.na(moving), time_sec != -2)%>%
  group_by(time_sec)%>%
  summarise(moving = sum(moving, na.rm = T) , n = n())%>%
  mutate(prop_moving = moving/n, 
         group = if_else(time_sec < 59, 'before the drop', if_else(time_sec > 62, 'after the drop', 'drop')))

ggplot(bd_avg2, aes(x = time_sec, y = prop_moving)) +
  geom_line() +
  geom_point(aes(color = group)) +
  labs(title = 'manual tracking', x = 'seconds', y = 'proportion moving') +
  scale_y_continuous(limits = c(0,1))
```

As expected, the patterns are very similar to those observed for 'average speed' above. The auto tracker seems to miss some movements at the start of the recording, which probably has to do with how quickly the video's 'background' is established and then subtracted out by the movement detection algorithm. It also detects less movement overall, due to the higher frame rate - more movement can happen in 2 seconds (manual frame rate) than in an 1/8 of a second (auto frame rate).

Now we plot the second variable: how far a copepod moves, given that it is moving. I'll call this hop distance, as this implies movement. Here there is a conspicuous difference between auto and manually tracked data.
```{r}
bdr_avg3 <- filter(bdr, moving == 1)%>%
  group_by(sec)%>%
  summarize(mean_dist = mean(distance, na.rm=T), sd = sd(distance), n = n())%>%
  mutate(se = sd/sqrt(n),
         group = if_else(sec < 58.5, 'before the drop', if_else(sec > 61.5, 'after the drop', 'drop')))

ggplot(filter(bdr_avg3, group != 'drop'),
       aes(x = sec, y = mean_dist, color = group, fill = group)) + 
  geom_ribbon(aes(ymin = mean_dist - 1.96*se, ymax = mean_dist + 1.96*se)) +
  geom_path(color = 'black') +
  labs(title = 'auto tracker', x = 'seconds', y = 'mean hop distance + CI')

```
```{r}
bd_avg3 <- filter(bd, moving == 1, time_sec != -2)%>%
  group_by(time_sec)%>%
  summarize(mean_hop_dist = mean(dist, na.rm=T), sd = sd(dist), n =n())%>%
  mutate(se = sd/sqrt(n),
         group = if_else(time_sec < 59, 'before the drop', if_else(time_sec > 62, 'after the drop', 'drop')))

ggplot(filter(bd_avg3, group != 'drop'),
       aes(x = time_sec, y = mean_hop_dist, color = group, fill = group)) + 
  geom_ribbon(aes(ymin = mean_hop_dist - 1.96*se, ymax = mean_hop_dist + 1.96*se)) +
  geom_path(color = 'black') +
  labs(title = 'manual tracking', x = 'seconds', y = 'mean hop distance + CI')
```

Right after the drop, copepods seems to exhibit large movements in the auto dataset, which is tempting to interpet as escape movements, but the opposite is seen in the manual tracking data. There copepods exhibit smaller hops after the drop. So, again it looks like there some auto-tracking artifacts, probably due to the background being shifted when a plate is dropped. However, looking beyond the time period shortly after the drop, we see the hop distances are rather comparable before and after the plate drop. So, copepods do not appear to clearly alter their behavior by moving faster or slower in response to the drop.

Time moving and hop distance exhibit different patterns over the recording, suggesting they are not correlated and thus provide some independent information on copepod behavior. However, we can check the correlation between these two variables. The next plot shows the average hop distance during a recording as a function of the time spent moving.

```{r}
# remove drop and missing data
bdr_comp <- filter(bdr, sec < 59 | sec > 61, !is.na(distance))%>%
  group_by(fname)%>%
  summarise(n = n(), tot_dist = sum(distance), moving = sum(moving))%>%
  mutate(avg_vel = tot_dist/n, avg_vel_when_moving = tot_dist/moving, prop_moving = moving/n)

ggplot(bdr_comp, aes(x = prop_moving, y = avg_vel_when_moving)) + 
  geom_point(alpha = 0.051) +
  geom_smooth(method = 'lm', se = F) +
  labs(title = 'auto tracking', x = 'proportion moving', y = 'mean hop distance')
```

There are very high hop distance values in copepods that hardly moved. This is because, when few movements are detected, a single large, perhaps-erroneously-recorded movement determines the average hop distance. When we zoom in to exclude the copepods with a few, high magnitude movements, then we see that there is not a strong correlation between these variables. The residual variation suggests that in some recordings copepods are more slow and steady movers while in others they are more fast and jerky. 

```{r}
ggplot(bdr_comp, aes(x = prop_moving, y = avg_vel_when_moving)) + 
  geom_point(alpha = 0.3) +
  geom_smooth(method = 'lm', se = F) +
  scale_x_continuous(limits = c(0.05, 0.9)) + scale_y_continuous(limits = c(0,10)) +
  labs(title = 'auto tracking', x = 'proportion moving', y = 'mean hop distance')
```

In this experiment, we want to know how infection affects where copepods land on this plot. Additionally, we would like to know if there is a clear response to the plate drop in one or both of these variables. Let's add median values for the infection groups to the above plot and split it by the recording period, before and after the drop.

```{r}
# new ways of showing two responses, trt, and recording time together
bdr_avg4 <- filter(bdr, sec < 58 | sec > 62, !is.na(distance))%>%
  mutate(drop = if_else(sec < 60, 'before', 'after'))%>%
  group_by(fname, drop)%>%
  summarise(n = n(), tot_dist = sum(distance), moving = sum(moving))%>%
  mutate(avg_vel = tot_dist/n, avg_vel_when_moving = tot_dist/moving, prop_moving = moving/n)%>%
  mutate(drop = factor(drop, levels = c('before', 'after')))

# avg for 3 trts
bdr_avg4 <- left_join(bdr_avg4, select(bdr, fname, cop_name)%>%distinct())
bdr_avg4 <- left_join(bdr_avg4, select(infd, cop_name, trt))
bdr_avg4_inf <- ungroup(bdr_avg4)%>%
  group_by(trt,drop)%>%
  summarize(n = n(),
            avg_vel = median(avg_vel), 
            avg_vel_when_moving = median(avg_vel_when_moving, na.rm=T), 
            prop_moving = median(prop_moving),
            sd_vel = sd(avg_vel_when_moving, na.rm = T),
            sd_prop = sd(prop_moving, na.rm = T))

ggplot(filter(bdr_avg4, prop_moving > 0.0),
       aes(x = prop_moving, y = avg_vel_when_moving)) + 
  geom_point(alpha = 0.1) + geom_smooth() + 
  geom_point(data = bdr_avg4_inf, 
             aes(x = prop_moving, y = avg_vel_when_moving, color = trt),
             size = 5) +
  facet_grid(~drop) + 
  scale_y_log10() +
  labs(title = 'auto tracker', x = 'proportion moving', y = 'hop distance')
# tried adding error bars, but couldn't get them to look reasonable given skew in the data
```
```{r}
bd_avg4 <- filter(bd, time_sec < 59 | time_sec > 61, !is.na(dist))%>%
  mutate(drop = if_else(time_sec < 60, 'before', 'after'))%>%
  group_by(fname, drop)%>%
  summarise(n = n(), tot_dist = sum(dist), moving = sum(moving))%>%
  mutate(avg_vel = tot_dist/n, avg_vel_when_moving = tot_dist/moving, prop_moving = moving/n,
         drop = factor(drop, levels = c('before', 'after')))

bd_avg4$avg_vel_when_moving[which(is.infinite(bd_avg4$avg_vel_when_moving))]<-NA

bd_avg4 <- left_join(bd_avg4, select(bd, fname, cop_name)%>%distinct())
bd_avg4 <- left_join(bd_avg4, select(infd, cop_name, trt))

bd_avg4_inf <- ungroup(bd_avg4)%>%
  group_by(trt, drop)%>%
  summarize(avg_vel = mean(avg_vel), 
            avg_vel_when_moving = mean(avg_vel_when_moving, na.rm=T), 
            prop_moving = mean(prop_moving))

ggplot(filter(bd_avg4, prop_moving > 0.0),
       aes(x = prop_moving, y = avg_vel_when_moving)) + 
  geom_point(alpha = 0.1) + geom_smooth() + 
  geom_point(data = bd_avg4_inf, 
             aes(x = prop_moving, y = avg_vel_when_moving, color = trt),
             size = 5) +
  facet_grid(~drop) + 
  # scale_y_log10() +
  labs(title = 'manual tracking', x = 'proportion moving', y = 'hop distance')
```

Again, there are idiosyncratic differences between the datasets (like the aforementioned spurious combinations of large hops with little movement in the auto-tracking dataset). Nevertheless, the qualitative patterns appear similar in both datasets. The infecteds clearly spend less time moving than uninfecteds (shifted on the x-axis), but their hops are comparable (minimal shift along the y-axis). Additionally, response to the drop are subtle, suggesting copepods do not massively change how or how much they move in response to the 'shock'. Indeed, the time-series (plots above)[] suggest that on average they recover to pre-drop levels within a minute.

Here's another way to visualize treatment and drop effects in the two behavior variables. Until now, we have looked at averages across recordings and groups, ignoring how copepods respond to the drop within a recording. The next plots show how individuals respond to the drop, first for proportion of time moving. The overall averages are plotted in bold.

```{r}
ggplot(bdr_avg4, aes(x = drop, y = prop_moving, color = trt)) + 
  geom_line(aes(group = fname), alpha = 0.1) +
  geom_point(data = bdr_avg4_inf, aes(x = drop, y = prop_moving), size = 3) +
  geom_line(data = bdr_avg4_inf, aes(group = trt), size = 3) +
  facet_grid(~trt) +
  labs(title = 'auto tracker', y = 'proportion moving', color = 'treatment')
```
```{r}
ggplot(bd_avg4, aes(x = drop, y = prop_moving, color = trt)) + 
  geom_line(aes(group = fname), alpha = 0.05) +
  geom_point(data = bd_avg4_inf, aes(x = drop, y = prop_moving), size = 3) +
  geom_line(data = bd_avg4_inf, aes(group = trt), size = 3) +
  facet_grid(~trt) +
  labs(title = 'manual tracker', y = 'proportion moving', color = 'treatment')
```
The qualitative pattern is very similar in the two datasets - infecteds spend less time moving in general and all groups reduce activity after the drop. The values are higher in the manual data, but this makes sense given it's lower frame rate, i.e. more movement is possible within 2 seconds than an 1/8 of a second.

Making the same plot for our second response variable, hop distance...

```{r}
ggplot(bdr_avg4, aes(x = drop, y = avg_vel_when_moving, color = trt)) + 
  geom_line(aes(group = fname), alpha = 0.05) +
  geom_point(data = bdr_avg4_inf, aes(x = drop, y = avg_vel_when_moving), size = 3) +
  geom_line(data = bdr_avg4_inf, aes(group = trt), size = 3) +
  scale_y_log10() +
  facet_grid(~trt) +
  labs(title = 'auto tracker', y = 'hop distance', color = 'treatment')
```
```{r}
ggplot(bd_avg4, aes(x = drop, y = avg_vel_when_moving, color = trt)) + 
  geom_line(aes(group = fname), alpha = 0.05) +
  geom_point(data = bd_avg4_inf, aes(x = drop, y = avg_vel_when_moving), size = 3) +
  geom_line(data = bd_avg4_inf, aes(group = trt), size = 3) +
  facet_grid(~trt) +
  scale_y_log10() +
  labs(title = 'manual tracker', y = 'hop distance', color = 'treatment')
```

Here the pattern is a little differnt. In neither dataset is there much of a change due to the drop - copepod hops are of a similar magnitude before and after being frightened. Thus, the main response to the drop is fewer movements, not a change in the type of movements. In the manual dataset, the infecteds seem to have slightly smaller hops than uninifecteds, but this is not seen in the auto-tracked dataset.

We can also make these plots for average speed, the composite of time moving and hop distance.

```{r}
ggplot(bdr_avg4, aes(x = drop, y = avg_vel, color = trt)) + 
  geom_line(aes(group = fname), alpha = 0.05) +
  geom_point(data = bdr_avg4_inf, aes(x = drop, y = avg_vel), size = 3) +
  geom_line(data = bdr_avg4_inf, aes(group = trt), size = 3) +
  facet_grid(~trt) +
  labs(title = 'auto tracker', y = 'speed', color = 'treatment')
```
```{r}
ggplot(bd_avg4, aes(x = drop, y = avg_vel, color = trt)) + 
  geom_line(aes(group = fname), alpha = 0.05) +
  geom_point(data = bd_avg4_inf, aes(x = drop, y = avg_vel), size = 3) +
  geom_line(data = bd_avg4_inf, aes(group = trt), size = 3) +
  facet_grid(~trt) +
  labs(title = 'manual tracker', y = 'speed', color = 'treatment')
```

The pattern is quite similar in both datasets. Average speed decreases in response to the drop, particularly in the uninfected groups because they were more active to begin with. Infected copepods are less active regardless of whether they are observed before or after the drop.

To summarize, Infected copepods spend less time moving than uninfected copepods, but when they are moving their 'hops' are of a similar magnitude. In response to the drop, copepods also reduce how often they move, but not how fast they move, i.e. their 'hops' are similar. Given these results, my preference is to *not* break movement in multiple variables in further analyses. First and foremost, this is simpler. Hop distance seems relatively unaffected by infection or the drop, so it is not obvious this variable reflects anything of biological importance. Additionally, analyzing multiple variables increases the opportunity for false positives (p-hacking), which is relevant when we get to the main analysis, i.e. comparing genotype by genotype interactions. Alternatively, I could just use time moving as the response, because infection and drop effects are most clearly seen here. However, this would exclude all information on copepod speed/distance, which also seems excessive. The composite measure can be conveniently called 'activity' and expressed as either a distance or a speed.

One issue to address at the modelling phase is the unusual distribution of activity. Here it is at the frame level.

```{r}
# frame level
ggplot(bdr, aes(x = distance)) + 
  geom_histogram(binwidth = 0.1) +
  coord_cartesian(xlim = c(0,5)) +
  labs(x = 'distance moved per frame', title = 'auto tracker')
```

And here at the composite level of average activity across a recording.

```{r}
# composite level
ggplot(bdr_avg4, aes(x=tot_dist)) + 
  geom_histogram(binwidth = 20) + 
  facet_grid(~drop) +
  labs(title = 'auto tracker', x = 'distance moved in 1 min')
```

In both cases, it is quite skewed, though less so when averaged. We'll return to this issue when we start building statistical models, but now let's look at one more potential response variable that can be extracted from the tracking data.

### Angle of movements

Another aspect of behavior that can be extracted from the recordings is the direction moved by copepods, like whether they moved forwards or backwards. I calculated the angle of movement between consecutive video frames.

```{r}
# calculate angle of movement for auto-tracked data
bdr <- mutate(bdr, x0 = lag(x), x2 = lead(x), y0 = lag(y), y2 = lead(y))%>%
    mutate(dist1 = sqrt((x0 - x)^2 + (y0 - y)^2) )%>%
    mutate(dist2 = sqrt((x - x2)^2 + (y - y2)^2) )%>%
    mutate(angle = acos(dot_product/(dist1 * dist2)) * 180/pi)%>%
    select(fname, frame, sec, x, y, blobs, blob_size, 
           distance, dot_product, angle)

# remove the angle calc for first observation in each recording
x <- group_by(bdr, fname)%>%
  summarize(frame_min = min(frame))%>%
  mutate(mv = paste(fname, frame_min))

bdr <- mutate(bdr, mv = paste(fname, frame))
bdr$angle[which(bdr$mv %in% x$mv)] <- NA
bdr <- select(bdr, -mv)
```

```{r}
# calculate angle of movement for manually-tracked data
bd <- mutate(bd, x0 = lag(x), x2 = lead(x), y0 = lag(y), y2 = lead(y))%>%
    mutate(dist1 = sqrt((x0 - x)^2 + (y0 - y)^2) )%>%
    mutate(dist2 = sqrt((x - x2)^2 + (y - y2)^2) )%>%
    mutate(dot_product = ((x2 - x) * (x - x0) + (y2 - y) * (y - y0)))%>%
    mutate(angle = acos(dot_product/(dist1 * dist2)) * 180/pi)%>%
    select(fname, day, slice, time_sec, x, y, 
           dist, dot_product, angle)

# remove the angle, dot_product calc for first observation in each recording
x <- group_by(bd, fname)%>%
  summarize(frame_min = min(slice))%>%
  mutate(mv = paste(fname, frame_min))
bd <- mutate(bd, mv = paste(fname, slice))
bd$angle[which(bd$mv %in% x$mv)] <- NA
bd$dot_product[which(bd$mv %in% x$mv)] <- NA
bd <- select(bd, -mv)
```

Here is the distribution of movement angles in both datasets.

```{r}
ggplot(bdr, aes(x = angle)) + geom_histogram(binwidth = 10) +
  labs(title = 'auto tracker')
```
```{r}
ggplot(bd, aes(x = angle)) + geom_histogram(binwidth = 10) +
  labs(title = 'manual tracking')
```

The distributions clearly differ; there are more forwards movements in the manual data and far more backwards movements in the auto data (angle values near 180). This is partly due to the different time scales of the datasets. The auto-tracking data recorded copepod position 8 times per second, and consequently there was a lot of opportunity for slight oscillations of the tracker back and forth (i.e. high angles). By contrast, copepod position was recorded once every two seconds in the manual dataset, so there should be less 'noise' oscillations. 

We can understand the difference between the datasets by plotting angle vs the distance moved.

```{r}
bdr <- mutate(bdr, group = if_else(sec < 58, 'before the drop', 
                         if_else(sec > 62, 'after the drop', 'drop')))

ggplot(filter(bdr, sec<58|sec>62)%>%sample_n(100000), 
       aes(x = angle, y = distance, color = group)) + 
  geom_point(alpha = 0.01) +
  geom_smooth(se=F) +
  scale_y_continuous(limits = c(0, 30)) +
  labs(title = 'auto tracking')
```

```{r}
bd <- mutate(bd, group = if_else(time_sec < 59, 'before the drop', 
                         if_else(time_sec > 61, 'after the drop', 'drop')))
ggplot(filter(bd, group != 'drop'), aes(x = angle, y = dist, color = group)) +
  geom_point(alpha = 0.01) + geom_smooth(se=F) +
  labs(title = 'manual tracking')
```

Forward movements (low angles) tend to be larger in both datasets. But in the auto-tracked dataset, there is an overabundance of backward movements, most of which are small, though some are large. Large backwards movements are tracking mistakes - the auto-tracker incorrectly jumps to one part of the well and then back again. I took steps to correct these mistakes (see [here](GITHUB)), but was perhaps too conservative in eliminating these kinds of movements. 

In neither dataset is there evidence that the drop markedly changed the directions moved. Copepods do not more often move backwards or in a zig-zag pattern for instance. We can also visualize this by plotting average movement direction over the recording.

```{r}
bdr_avg <- group_by(bdr, sec)%>%
  summarize(mean_dir = mean(angle, na.rm = T),
            var_dir = var(angle, na.rm = T))%>%
  mutate(group = if_else(sec < 58.5, 'before the drop', 
                         if_else(sec > 61.5, 'after the drop', 'drop')))

ggplot(bdr_avg, aes(x = sec, y = mean_dir)) + 
  geom_path() + geom_point(aes(color=group)) +
  scale_x_continuous(limits = c(0,120), breaks = seq(0, 120, by = 10)) +
  labs(title = 'angle - auto tracker')
```
```{r}
bd_avg <- group_by(bd, time_sec)%>%
  summarize(mean_dir = mean(angle, na.rm=T),
            var_dir = var(angle, na.rm=T))%>%
  mutate(group = if_else(time_sec < 59, 'before the drop', 
                         if_else(time_sec > 62, 'after the drop', 'drop')))

ggplot(bd_avg, aes(x = time_sec, y = mean_dir)) + 
  geom_path() + geom_point(aes(color=group)) +
  scale_x_continuous(limits = c(0,119), breaks = seq(0, 120, by = 10)) +
  labs(title = 'angle - manual tracker')
```

The time-dependence of average movement angle differs in the two datasets. The drop induces changes in opposite directions in the two datasets. The auto-tracker 'resets' at the drop (i.e. background subtraction of the video frames starts over), so it may not spot the copepod immediately. Once it is tracking something, the small back-and-forth oscillations then dominate and determine the mean values. In the manual dataset, the average tended to be lower, around 45 degrees, which corresponds closely to typical copepod movements along the edge of the circular wells. Also, the increase in angle values right after the drop in the manual data could indicate more sideways or backwards movement by copepods, but this should not be over-interpreted because this was also where copepods moved the least. One consistent feature of both datasets: angle values return to 'pre-drop' levels very quickly, suggesting the kinds of movements made by copepods were not fundamentally altered by this shock.

Given that (i) the auto-tracker seems to introduce a lot of noise into this variable measure and (ii) there is not an obvious response to the drop, this variable does not look so interesting. But before ignoring it, I want to check whether movement angles differs between infected and uninfected copepods.

```{r}
bdr <- mutate(bdr, cop_name = substring(fname, 1, 5))%>%
  mutate(dist_cat = cut(distance, breaks = c(0, 0.5, 2, 7)))

bd_i <- left_join(bdr, infd, by = 'cop_name')

ggplot(filter(bd_i, group != 'drop', !is.na(dist_cat)),
       aes(y = angle, x = trt2)) +
  geom_boxplot() +
  labs(title = 'auto tracking - facetted by movement distance', x = 'treatment') +
  facet_grid(group~dist_cat)
```

```{r}
bd <- mutate(bd, cop_name = substring(fname, 1, 5))%>%
  mutate(dist_cat = cut(dist, breaks = c(0, 0.5, 2, 7)))
bd_i <- left_join(bd, infd, by = 'cop_name')

ggplot(filter(bd_i, group != 'drop', !is.na(dist_cat)),
       aes(y = angle, x = trt2)) +
  geom_boxplot() +
  labs(title = 'manual tracking - facetted by movement distance', x = 'treatment') +
  facet_grid(group~dist_cat)
```

There is no conspicuous difference between treatments in either dataset, regardless of whether movements are large or small or whether they were before or after the drop. A similar way to assess this by calculating dot products for movements. The dot product of two vectors combines information about vector magnitudes and directions into a single value. [Elsewhere](GITHUB) I compared dot products among treatments and found that they do not differ. Thus, there seems to be little to gain by looking at the *direction* copepods move - it does not respond to the drop nor does it differ between treatments.

To this point, we have considered differ ways of recording copepod behavior and have found that 'activity', a combination of how much and how far they move, is a simple measure that captures the behavior of biological interest. Next, I consider ways to further simplify this variable for downstream analyses. 

## Simplifying behavioral measurements

### Reducing the frame rate

Previous studies recorded copepods at 1 frame per 2 sec (LINKS!!)[XXX], which preliminary experiments determined was optimal for manual tracking - only a small number of frames needed to be clicked through and it did not miss much movement. By comparison, the auto tracker used 8 frames/sec, a frame rate 16 times higher. This high rate was used because each frame helped establish the recording's 'background', which was then subtracted out to detect movement from one frame to the next. Recording a copepod's position every 1/8 of a second is presumably overkill; it probably detects superfluous movements and creates an unnecessarily large dataset. But how much should we reduce the frame rate? To evaluate this, I averaged copepod position across frames for several frame rates and then recalculated the distance moved between frames. To compare different frame rates, I summed the total distance moved during the recording - if much information is lost with lower frame rates, then the correlation between the full and the reduced-frame-rate datasets should decrease.

```{r}
# reduce the data frame to different frame rates...
# get cop position and distance for 1 frame per 4 s - less than even manual rate
bdr_1per4s <- mutate(bdr, fg = cut(sec, 30))%>%
  group_by(fname, fg)%>%
  summarize(x = mean(x), y = mean(y))%>%
  mutate(x0 = lag(x), y0 = lag(y))%>%
  mutate(dist = sqrt((x0 - x)^2 + (y0 - y)^2))%>%
  select(fname, fg, dist)

# get cop position and distance for 1 frame per 2 s
bdr_1per2s <- mutate(bdr, fg = cut(sec, 60))%>%
  group_by(fname, fg)%>%
  summarize(x = mean(x), y = mean(y))%>%
  mutate(x0 = lag(x), y0 = lag(y))%>%
  mutate(dist = sqrt((x0 - x)^2 + (y0 - y)^2))%>%
  select(fname, fg, dist)

# for 1 frames per s
bdr_1pers <- mutate(bdr, fg = cut(sec, 120))%>%
  group_by(fname, fg)%>%
  summarize(x = mean(x), y = mean(y))%>%
  mutate(x0 = lag(x), y0 = lag(y))%>%
  mutate(dist = sqrt((x0 - x)^2 + (y0 - y)^2))%>%
  select(fname, fg, dist)

# for 2 frames per s
bdr_2pers <- mutate(bdr, fg = cut(sec, 240))%>%
  group_by(fname, fg)%>%
  summarize(x = mean(x), y = mean(y))%>%
  mutate(x0 = lag(x), y0 = lag(y))%>%
  mutate(dist = sqrt((x0 - x)^2 + (y0 - y)^2))%>%
  select(fname, fg, dist)

# for 4 frames per s
bdr_4pers <- mutate(bdr, fg = cut(sec, 480))%>%
  group_by(fname, fg)%>%
  summarize(x = mean(x), y = mean(y))%>%
  mutate(x0 = lag(x), y0 = lag(y))%>%
  mutate(dist = sqrt((x0 - x)^2 + (y0 - y)^2))%>%
  select(fname, fg, dist)
```

```{r}
# calc tot distance moved over recording in auto-tracked data at diff frame rates
bdr_td <- group_by(bdr, fname)%>%
  summarize(dist_full = sum(distance, na.rm = T))

bdr_td_1per4s <- group_by(bdr_1per4s, fname)%>%
  summarize(dist_1per4s = sum(dist, na.rm = T))

bdr_td_1per2s <- group_by(bdr_1per2s, fname)%>%
  summarize(dist_1per2s = sum(dist, na.rm = T))

bdr_td_1pers <- group_by(bdr_1pers, fname)%>%
  summarize(dist_1pers = sum(dist, na.rm = T))

bdr_td_2pers <- group_by(bdr_2pers, fname)%>%
  summarize(dist_2pers = sum(dist, na.rm = T))

bdr_td_4pers <- group_by(bdr_4pers, fname)%>%
  summarize(dist_4pers = sum(dist, na.rm = T))

# combine for plotting
bdr_comp <- left_join(bdr_td, bdr_td_1per4s)
bdr_comp <- left_join(bdr_comp, bdr_td_1per2s)
bdr_comp <- left_join(bdr_comp, bdr_td_1pers)
bdr_comp <- left_join(bdr_comp, bdr_td_2pers)
bdr_comp <- left_join(bdr_comp, bdr_td_4pers)
```

As expected, the correlation (r^2^ on the y-axis below) between the full dataset and the reduced datasets decreases as the frame rate is reduced. However, even when the frame rate is reduced 8-fold to 1 per sec, r^2^ is still quite high (0.9), indicating that we are not losing much information on copepod movement. And some of the lost information might be meaningless, random noise, i.e. the tiny oscillations between frames that are averaged out at lower frame rates.

```{r}
ctab <- cor(select(bdr_comp, -fname), use = "pairwise.complete.obs")

fr = c(8, 0.25, 0.5, 1, 2, 4)

cor_plot <- data.frame(frame_rate = fr,
                       frames_per_rec = fr * 120,
                       r2 = ctab[1,]^2)
                    
ggplot(cor_plot, aes(x = frame_rate, y = r2)) + geom_point() + geom_line() +
  scale_x_reverse()
```

Subjectively, a frame rate of 2 per second seems like a reasonable compromise. It reduces the auto-tracked data 4-fold, while retaining much of the information (r^2^ = 0.93). Conversely, compared to the manually-tracked data, this retains 4x more data on copepod position, though as mentioned before, previous work did not indicate a lot of information gain through a frame rate higher than 1 per 2 seconds. In the end, the reduction in frame rate is a practical decision, unlikely to bias or gloss over differences between treatments.

```{r}
# remove unneeded data frames
rm(list = ls(pattern = "bdr_td"))
rm(list = ls(pattern = "bdr_1p"))
rm(bdr_comp, cor_plot, ctab, fr, bdr_4pers)
```

In fact, when we plot the differences between treatments, the pattern is unchanged.

```{r}
# re-cut the sec variable more carefully
bdr_2pers <- mutate(bdr, fg = cut(sec, seq(0, 120, by = 0.5), right = F, include.lowest = T))%>%
  group_by(fname, fg)%>%
  summarize(x = mean(x), y = mean(y), n = n())%>%
  mutate(x0 = lag(x), y0 = lag(y))%>%
  mutate(dist = sqrt((x0 - x)^2 + (y0 - y)^2))%>%
  select(fname, fg, dist)

# add quantitative sec var back to reduced frame rate dataset
secfg <- data.frame(fg = unique(bdr_2pers$fg), sec = seq(0, 119.5, by = 0.5))
bdr_2pers <- left_join(bdr_2pers, secfg)

# add infection data
bdr_2pers <- mutate(bdr_2pers, cop_name = substring(fname, 1, 5))
bdr_2pers <- left_join(bdr_2pers, select(infd, cop_name, trt), by = 'cop_name')
```
```{r}
#average for each second across recordings
bdr_2pers_avg <- group_by(bdr_2pers, sec, trt)%>%
  summarize(dist = mean(dist, na.rm=T))

ggplot(filter(bdr_2pers_avg, sec < 59 | sec > 61),
       aes(x = sec, y = dist, color = trt)) +
  geom_path() +
  labs(title = 'auto tracker - values during drop removed', y = 'mean activity', x = 'seconds')
```

```{r}
# sum moved for auto tracker full, auto tracker reduced, manual tracker
bdr_td <- group_by(bdr, fname)%>%
  summarize(dist_full = sum(distance, na.rm = T))
bdr_td2pers <- group_by(bdr_2pers, fname)%>%
  summarize(dist_full_2pers = sum(dist, na.rm = T))
bd_td <- group_by(bd, fname)%>%
  summarize(dist_full_man = sum(dist, na.rm = T))

# get correlations with manual data
bd_comp1 <- left_join(bdr_td, bd_td, by = 'fname')
bd_comp2 <- left_join(bdr_td2pers, bd_td, by = 'fname')

cor1 <- cor(select(bd_comp1, -fname), use = "pairwise.complete.obs")
cor2 <- cor(select(bd_comp2, -fname), use = "pairwise.complete.obs")
```

The reduction in frame rate also makes the data more similar to the manual dataset. Using the total distance moved over a recording, we find the correlation between the full auto-tracked data and the manual data to be `r round(cor1[1,2],2)`. The correlation between the 4-fold reduced frame rate data and the manual dataset is larger at `r round(cor2[1,2],2)`, as we would expect. 

In sum, I believe the reduced-frame-rate dataset has several advantages. One, it reduces the full dataset significantly (4x), easing statistical modelling. Two, it is more similar to the manual dataset, yet it still retains additional movement information (though I don't know if this extra info represents improved tracking or just random noise). Three, it retains additional recordings that were not in the manual dataset (manual processing was tedious and slow, so it was not done for all recordings). Finally, using auto-tracked data circumvents some of the flaws in the dataset I previously discovered (see [here](LINK!!!)).

```{r}
rm(cor1, cor2, bd_comp1, bd_comp2, bdr_td, bd_td, bdr_td2pers)
```

### Categorizing sections of the recording

Even with a reduced frame rate, there is still substantial pseudoreplication in the data - within a recording, observations are separated by half a second and are conceivably highly correlated. In [previous analyses](LINK!!), we fit mixed models to account for this (i.e. treat recording as a random effect). However, this might be insufficient, because it assumes the same covariance between all observations within a recording. In other words, it does not differentiate between two observations in the same recording that are 2 seconds apart or that are 20 seconds apart. A solution would be to fit some kind of autoregressive function that models how similarity decays over time within a recording. But this would not be straightforward. When we look at individual recordings as time series plot, we see peaks (the copepod is hopping) and valleys (the copepod is stationary). The temporal autocorrelation that we see when we average over all recordings (see [plot above](LINK!!!)) is not evident in individual recordings. A further challenge would be assessing whether the same autoregression function fits both before and after the drop.

```{r}
rrec <- sample(bdr$fname, size = 5)
ggplot(filter(bdr_2pers, fname %in% rrec),
       aes(x = sec, y = dist, color = fname)) +
  geom_line(aes(group = fname)) +
  guides(color = F) +
  labs(title = 'looking for autocorrelation in 5 random recordings')
```
 
Thus, modelling this data at the level of individual frames appears quite complex. The old-fashioned approach of averaging out pseudoreplication might be easier for readers to understand.

Before this, though, we need to closely examine how behavior changes within a recording so as not to average out any potentially interesting temporal variation. At a minimum, we can define two parts of the recording: before and after the drop. Let's re-plot how average behavior changes over a recording, this time with confidence intervals (they are underestimated, as I have not accounted for the fact that each copepod was recorded on multiple days).

```{r}
bdr_2pers <- mutate(bdr_2pers, group = if_else(sec < 58.5, 'before the drop', 
                         if_else(sec > 61.5, 'after the drop', 'drop')))
bdr_avg <- group_by(bdr_2pers, sec, group)%>%
  summarize(mean_dist = mean(dist, na.rm=T),
            sd_dist = sd(dist, na.rm = T),
            n = n())%>%
  mutate(se = sd_dist/sqrt(n))%>%
  mutate(uci = mean_dist + 2.6*se,
         lci = mean_dist - 2.6*se)
```
```{r}
ggplot(filter(bdr_avg, group != 'drop'),
       aes(x = sec, y = mean_dist, fill = group)) +
  geom_ribbon(aes(ymin = lci, ymax = uci), alpha = 0.5) +
  geom_line() +
  labs(title = 'auto tracker - 99% CIs')
```


```{r}
bd_avg <- group_by(bd, time_sec)%>%
  summarize(mean_dist = mean(dist, na.rm=T),
            sd_dist = sd(dist, na.rm = T),
            n = n())%>%
  mutate(se = sd_dist/sqrt(n))%>%
  mutate(uci = mean_dist + 2.6*se,
         lci = mean_dist - 2.6*se)%>%
  mutate(group = if_else(time_sec < 59, 'before the drop', 
                         if_else(time_sec > 62, 'after the drop', 'drop')))
```
```{r}
ggplot(filter(bd_avg, group != 'drop', time_sec != -2),
       aes(x = time_sec, y = mean_dist, fill = group)) +
  geom_ribbon(aes(ymin = lci, ymax = uci), alpha = 0.5) +
  geom_line() +
  labs(title = 'manual tracker - 99% CIs')
```

We saw these patterns before - a decrease in activity after the drop, followed by a rather quick recovery, with some minor differences between datasets. Can we categorize sections of the recording to both capture this temporal variation and simplify analyses? There is not an obvious biological reason to split the 'before' group, given that it experiences constant conditions. Perhaps it could be split to account for technical variation, such as the slightly lower activity levels at the beginning of the recording (presumably due to the copepod not being tracked right away - it needs to be spotted before it can be followed). The 'after' group could be split to account for the recovery over time, such as into a 'shocked' and 'recovering' phase, or even into three groups ('shocked', 'recovering', and 'recovered'). Let's see what that looks like.

```{r}
bdr_avg <- mutate(bdr_avg, group2 = if_else(group == 'before the drop', 'before', 
                                    if_else(sec>61.5 & sec<=80, 'shocked', 
                                            if_else(sec>80 & sec<100, 'recovering', 'recovered'))))
```
```{r}
ggplot(filter(bdr_avg, group != 'drop'),
       aes(x = sec, y = mean_dist, fill = group2)) +
  geom_ribbon(aes(ymin = lci, ymax = uci), alpha = 0.5) +
  geom_line() +
  labs(title = 'auto tracker - 99% CIs')
```

```{r}
bd_avg <- mutate(bd_avg, group2 = if_else(group == 'before the drop', 'before', 
                                          if_else(time_sec>61.5 & time_sec<=80, 'shocked', 
                                            if_else(time_sec>80 & time_sec<100, 'recovering', 'recovered'))))
```
```{r}
ggplot(filter(bd_avg, group != 'drop', time_sec != -2),
       aes(x = time_sec, y = mean_dist, fill = group2)) +
  geom_ribbon(aes(ymin = lci, ymax = uci), alpha = 0.5) +
  geom_line() +
  labs(title = 'manual tracker - 99% CIs')
```

There is not much difference between 'recovering' and 'recovered' groups, and the variation within these two groups is small. However, the 'shocked' group still covers a wide range, from hardly moving to moving at near-normal speeds. I suppose we could try to split this group further to reduce the within-group variance, but this seems subjective and not obviously biologically justifed. Moreover, as the categories get smaller so do sample sizes. This could result in failing to find treatment-differences in some categories, not because they do not exist but because power differs depending on which groups are being compared.

To step back, I have considered three approaches to deal with the non-independence of measurements within recordings. First, model it at the frame-by-frame level using time-series methods like autoregression, which seems overly complex, particularly since there are multiple time-series for each copepod (i.e. each copepod was recorded on multiple days - a second source of non-independence). Second, average out the pseudoreplication in a way that maintains temporal patterns, such as by defining categories like 'shocked', 'recovering', etc. This also has its problems, particularly it makes more comparisons with fewer samples. Third and simplest, average out the pseudoreplication, disregarding the fine-scale temporal variation. In other words, just take the average before and after the drop. I prefer this, because it is simple and justified by the experimental setup. Moreover, the main goal of the experiment is to assess genotype by genotype interactions. There were 5 host and 5 parasite strains (25 combinations) and making these comparisons across multiple temporal categories would result in a huge number of comparisons.

Still, we should show whether there are conspicuous differences between treatments in their behavior over a recording. Let's make a plot worthy of the supplementary material to demonstrate.

```{r}
bdr_avg <- group_by(bdr_2pers, sec, trt)%>%
  summarize(mean_dist = mean(dist, na.rm=T),
            sd_dist = sd(dist, na.rm = T),
            n = n())%>%
  mutate(se = sd_dist/sqrt(n))%>%
  mutate(uci = mean_dist + 2.6*se,
         lci = mean_dist - 2.6*se)

# introduce NAs at drop to exclude from plot
bdr_avg$mean_dist[which(bdr_avg$sec > 58.4 & bdr_avg$sec < 61.6)] <- NA
bdr_avg$uci[which(bdr_avg$sec > 58.4 & bdr_avg$sec < 61.6)] <- NA
bdr_avg$lci[which(bdr_avg$sec > 58.4 & bdr_avg$sec < 61.6)] <- NA

ggplot(bdr_avg,
       aes(x = sec, y = mean_dist, fill = trt)) +
  geom_ribbon(aes(ymin = lci, ymax = uci), alpha = 0.3) +
  geom_line(aes(color = trt)) +
  labs(title = 'Manual Tracker - 99% CIs', x = 'Seconds', y = 'Activity', fill = 'Treatment') +
  guides(color = FALSE) +
  annotate('rect', xmin = 58, xmax = 62, ymin = 0, ymax = 4, 
           alpha = 0.3, fill = 'gray') +
  annotate('text', x = 60, y = 2, angle = 90, label = 'Plate dropped') +
  scale_y_continuous(limits = c(0,4), expand = c(0,0))
```

As we have seen before, the infecteds are less active overall than the uninfecteds. The difference may be slightly smaller after the drop than before, but there is not a conspicuous difference in how the different group respond to the drop. The only part of the time-series where there is not a treatment difference (overlapping confidence intervals) is in the few seconds immediately after the drop. But the activity difference is quickly re-established, so breaking the recording into different sections to account for temporal differences between treatments in unnecessary.

# Summary

In this document, I presented descriptive statistics, examined potential response variables, and looked for ways to justifiably simplify this massive dataset. I decided that analyses should just use activity (expressed as either a distance or speed), as there was not much to gain by breaking movements down into their frequency, magnitude, and direction. Moreover, I found that little information was lost by reducing the frame rate in the auto-tracked dataset. Finally, I found that the mean difference betweeen infected and uninfected copepods was relatively consistent across a typical recording, obviating the need for complicated categorizations to follow changes in parasite manipulation over the course of recordings.

```{r}
# write data to new csvs!
# auto
bdr_avg <- filter(bdr_2pers, group != 'drop', !is.na(dist))%>% # removes data between 58.5 and 61.5 sec
  group_by(fname, group)%>%
  summarize(tot_dist = sum(dist, na.rm = T),
            var_dist = var(dist, na.rm = T),
            frames_tracked = n())
write.table(bdr_avg, file = "../data/behav_autotracked_reduced_dataset.csv", sep = ",", row.names = F)

# manual
bd_avg <- filter(bd, group != 'drop', !is.na(dist))%>%
  group_by(fname, group)%>%
  summarise(tot_dist = sum(dist, na.rm=T),
            var_dist = var(dist, na.rm=T),
            frames_tracked = n())
write.table(bd_avg, file = "../data/behav_manutracked_reduced_dataset.csv", sep = ",", row.names = F)
```

I wrote new, simplified data files for use in downstream analyses, one for the [auto-tracked](../data/behav_autotracked_reduced_dataset.csv) and one for the [manually-tracked data](../data/behav_manutracked_reduced_dataset.csv). Movement values were averaged within recordings (separately for before and after the drop), and in the case of the auto-tracked data, I used the reduced frame rate (2 per second).

The next step is go onto the main analyses and examine the role of host and parasite genotypes in determining the magnitude of parasitic manipulation. This analysis is conducted in a new [markdown]().